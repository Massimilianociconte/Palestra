<!DOCTYPE html>
<html lang="it">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, viewport-fit=cover">
    <title>Profilo | GYMBRO</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600&family=Oswald:wght@500;700&display=swap"
        rel="stylesheet">
    <link rel="manifest" href="manifest.json">
    <meta name="theme-color" content="#00f3ff">

    <!-- iOS Support -->
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="apple-mobile-web-app-title" content="GymBro">
    <link rel="apple-touch-icon" href="assets/icon.svg">

    <link rel="icon" type="image/svg+xml" href="assets/icon.svg">
    <link rel="stylesheet" href="css/style.css">
    <style>
        .profile-header {
            display: flex;
            align-items: center;
            gap: var(--spacing-md);
            margin-bottom: var(--spacing-md);
        }

        .avatar-container {
            position: relative;
            cursor: pointer;
        }

        .avatar {
            width: 80px;
            height: 80px;
            background: var(--color-surface);
            border: 2px solid var(--color-primary);
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 2rem;
            color: var(--color-primary);
            overflow: hidden;
            background-size: cover;
            background-position: center;
        }

        .avatar-overlay {
            position: absolute;
            bottom: 0;
            right: 0;
            background: var(--color-primary);
            color: black;
            width: 24px;
            height: 24px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 0.8rem;
            border: 2px solid var(--color-bg);
        }

        .setting-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 1.2rem 0;
            border-bottom: 1px solid var(--color-border);
            flex-wrap: wrap;
            gap: 1rem;
        }

        .setting-item:last-child {
            border-bottom: none;
        }

        .setting-label {
            font-weight: 500;
            color: var(--color-text-main);
            flex-shrink: 0;
        }

        .setting-control {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            flex-grow: 1;
            justify-content: flex-end;
        }

        .input-compact {
            padding: 0.5rem;
            background: rgba(0, 0, 0, 0.3);
            border: 1px solid var(--color-border);
            color: white;
            border-radius: var(--radius-sm);
            font-size: 0.9rem;
        }

        .btn-compact {
            padding: 0.5rem 1rem;
            font-size: 0.8rem;
            min-width: 80px;
        }

        .doms-chip-grid {
            display: flex;
            flex-direction: column;
            gap: 0.75rem;
            margin-top: 0.35rem;
        }

        .doms-chip-group {
            font-size: 0.75rem;
            letter-spacing: 0.05em;
            text-transform: uppercase;
            color: var(--color-text-muted);
        }

        .doms-chip-wrapper {
            display: flex;
            flex-wrap: wrap;
            gap: 0.4rem;
        }

        .wellness-modal {
            position: fixed;
            inset: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.85);
            z-index: 2100;
            padding: clamp(0.75rem, 4vw, 1.5rem);
            display: flex;
            align-items: center;
            justify-content: center;
            overflow-y: auto;
            backdrop-filter: blur(8px);
        }

        .wellness-modal-card {
            width: min(100%, 440px);
            border: 1px solid rgba(255, 255, 255, 0.15);
            border-radius: var(--radius-md);
            max-height: calc(100vh - clamp(1.5rem, 6vh, 3rem));
            overflow-y: auto;
            padding: clamp(1rem, 3vw, 1.5rem);
            background: var(--color-surface);
            box-shadow: 0 25px 70px rgba(0, 0, 0, 0.5);
            scrollbar-width: thin;
            scrollbar-color: var(--color-primary) rgba(255, 255, 255, 0.1);
        }

        .wellness-modal-card::-webkit-scrollbar {
            width: 6px;
        }

        .wellness-modal-card::-webkit-scrollbar-track {
            background: transparent;
        }

        .wellness-modal-card::-webkit-scrollbar-thumb {
            background: rgba(255, 255, 255, 0.25);
            border-radius: 999px;
        }

        @media (max-width: 640px) {
            .wellness-modal {
                align-items: flex-start;
            }

            .wellness-modal-card {
                max-height: calc(100vh - 1.5rem);
            }
        }

        .doms-chip {
            background: rgba(255, 255, 255, 0.08);
            border: 1px solid rgba(255, 255, 255, 0.12);
            color: #fff;
            border-radius: 999px;
            padding: 0.3rem 0.8rem;
            font-size: 0.8rem;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .doms-chip.active {
            background: rgba(0, 243, 255, 0.25);
            color: #000;
            border-color: rgba(0, 243, 255, 0.6);
            box-shadow: 0 0 10px rgba(0, 243, 255, 0.3);
        }

        .doms-chip:focus-visible {
            outline: 2px solid var(--color-primary);
            outline-offset: 2px;
        }

        .doms-chip-info {
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-size: 0.75rem;
            color: var(--color-text-muted);
            margin-top: 0.4rem;
        }

        /* Mobile specific adjustments for settings */
        @media (max-width: 480px) {
            .setting-item {
                flex-direction: column;
                align-items: stretch;
            }

            .setting-control {
                width: 100%;
                justify-content: stretch;
            }

            .setting-control input,
            .setting-control select,
            .setting-control button {
                width: 100%;
            }

            .setting-control form {
                width: 100%;
            }
        }

        .workout-list-item {
            background: var(--color-surface);
            padding: 1rem;
            margin-bottom: 0.5rem;
            border-radius: var(--radius-sm);
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .delete-workout {
            color: #ff4444;
            cursor: pointer;
            font-size: 0.9rem;
        }

        /* Auth Forms */
        .auth-container {
            display: none;
            /* Hidden by default */
        }

        .profile-content {
            display: none;
            /* Hidden by default */
        }

        .visible {
            display: block;
        }

        .form-group {
            margin-bottom: 1rem;
        }

        .form-group label {
            display: block;
            margin-bottom: 0.5rem;
            font-size: 0.9rem;
            color: var(--color-text-muted);
        }

        .form-group input {
            width: 100%;
            padding: 0.8rem;
            background: var(--color-bg);
            border: 1px solid var(--color-border);
            border-radius: var(--radius-sm);
            color: var(--color-text);
        }

        .text-center {
            text-align: center;
        }

        .link-btn {
            background: none;
            border: none;
            color: var(--color-primary);
            cursor: pointer;
            text-decoration: underline;
            padding: 0;
            font-size: 0.9rem;
        }

        .ai-badge {
            display: inline-flex;
            align-items: center;
            gap: 4px;
            background: rgba(0, 243, 255, 0.15);
            color: var(--color-primary);
            border: 1px solid rgba(0, 243, 255, 0.3);
            border-radius: 999px;
            font-size: 0.65rem;
            padding: 0 0.4rem;
            text-transform: uppercase;
            letter-spacing: 0.05em;
        }

        .ai-plan-card {
            background: rgba(255, 255, 255, 0.03);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: var(--radius-md);
            padding: clamp(0.75rem, 3vw, 1rem);
        }

        .ai-plan-section {
            margin-top: 1rem;
        }

        .ai-plan-section h5 {
            margin: 0;
            font-size: clamp(0.8rem, 2.8vw, 0.85rem);
            color: var(--color-text-muted);
            letter-spacing: 0.05em;
            text-transform: uppercase;
            line-height: 1.3;
        }

        .ai-plan-section ul {
            margin: 0.5rem 0 0;
            padding-left: 1.2rem;
            color: #ddd;
            font-size: clamp(0.85rem, 2.8vw, 0.9rem);
            line-height: 1.5;
        }

        .ai-plan-section li {
            margin-bottom: 0.4rem;
            word-wrap: break-word;
            overflow-wrap: break-word;
        }

        .btn-compact {
            padding: 0.3rem 0.8rem;
            font-size: clamp(0.75rem, 2.5vw, 0.85rem);
        }
    </style>
</head>

<body>

    <header class="header">
        <div class="container">
            <a href="index.html" class="logo">GYM<span class="text-primary">BRO</span></a>
            <nav>
                <div class="mobile-toggle" id="mobileToggle">‚ò∞</div>
                <ul class="nav-links" id="navLinks">
                    <li><a href="creator.html">Creator</a></li>
                    <li><a href="diary.html">Diario</a></li>
                    <li><a href="analysis.html">Analisi</a></li>
                    <li><a href="body.html">Corpo</a></li>
                    <li><a href="user.html" class="text-primary">Profilo</a></li>
                </ul>
            </nav>
        </div>
    </header>

    <section class="section" style="padding-top: 160px;">
        <div class="container">

            <!-- Auth Section (Login/Register) -->
            <div id="authSection" class="auth-container card" style="max-width: 400px; margin: 0 auto 2rem auto;">
                <h3 id="authTitle" class="text-center" style="margin-bottom: 1.5rem;">Accedi</h3>

                <form id="authForm">
                    <div class="form-group" id="nameGroup" style="display: none;">
                        <label>Nome</label>
                        <input type="text" id="nameInput" placeholder="Il tuo nome" autocomplete="name">
                    </div>
                    <div class="form-group">
                        <label>Email</label>
                        <input type="email" id="emailInput" required placeholder="email@esempio.com"
                            autocomplete="email">
                    </div>
                    <div class="form-group">
                        <label>Password</label>
                        <input type="password" id="passwordInput" required placeholder="******"
                            autocomplete="current-password">
                    </div>
                    <button type="submit" class="btn btn-primary" style="width: 100%; margin-top: 1rem;">Entra</button>
                </form>

                <p class="text-center" style="margin-top: 1rem; font-size: 0.9rem;">
                    <span id="authSwitchText">Non hai un account?</span>
                    <button id="authSwitchBtn" class="link-btn">Registrati</button>
                </p>
                <p id="authError" style="color: #ff4444; font-size: 0.9rem; text-align: center; margin-top: 1rem;"></p>
            </div>


            <!-- Profile Content (Logged In) -->
            <div id="profileContent" class="profile-content">
                <!-- Profile Header -->
                <div class="profile-header">
                    <div class="avatar-container" id="avatarContainer">
                        <div class="avatar" id="profileAvatar">üë§</div>
                        <div class="avatar-overlay">üì∑</div>
                        <input type="file" id="photoInput" accept="image/*" style="display: none;">
                    </div>
                    <div>
                        <h2 id="profileNameDisplay">Atleta <span class="text-primary">Pro</span></h2>
                        <p id="profileEmailDisplay" style="font-size: 0.9rem; color: var(--color-text-muted);">...</p>
                    </div>
                </div>

                <div class="grid" style="grid-template-columns: repeat(auto-fit, minmax(300px, 1fr)); gap: 2rem;">

                    <!-- Saved Workouts -->
                    <div>
                        <!-- AI PREDICTOR WIDGET -->
                        <div class="card"
                            style="margin-bottom: 2rem; border-color: var(--color-primary-dim); background: linear-gradient(135deg, rgba(0, 243, 255, 0.05) 0%, rgba(0,0,0,0) 100%);">
                            <div
                                style="display: flex; justify-content: space-between; align-items: center; flex-wrap: wrap; gap: 0.5rem; margin-bottom: 1rem;">
                                <div>
                                    <h3 style="font-size: 1.2rem; margin: 0;">‚ö° Prossima Sessione</h3>
                                    <p style="font-size: 0.75rem; color: var(--color-text-muted); margin: 0;">
                                        Suggerimenti personalizzati da Gemini AI</p>
                                </div>
                                <div style="display: flex; gap: 0.5rem;">
                                    <button id="aiPlanHistoryBtn" class="btn btn-outline btn-compact"
                                        style="font-size: 0.75rem;">üìö Storico</button>
                                    <button id="refreshAiPredictor" class="btn btn-primary btn-compact"
                                        style="font-size: 0.75rem;">ü§ñ Genera</button>
                                </div>
                            </div>
                            <div id="aiPredictorContent">
                                <p style="color: var(--color-text-muted); font-size: 0.9rem;">Chiedi all'IA cosa
                                    allenare oggi in base al tuo storico.</p>
                            </div>
                        </div>

                        <h3 style="margin-bottom: 1rem;">Le tue Schede</h3>
                        <div id="savedWorkoutsList">
                            <!-- Dynamic List -->
                        </div>
                        <a href="creator.html" class="btn btn-outline" style="width: 100%; margin-top: 1rem;">+ Nuova
                            Scheda</a>
                    </div>

                    <!-- Settings -->
                    <div class="card">
                        <h3
                            style="margin-bottom: 1.5rem; border-bottom: 1px solid var(--color-border); padding-bottom: 1rem;">
                            Impostazioni</h3>

                        <div class="setting-item">
                            <span class="setting-label">Nome Visualizzato</span>
                            <div class="setting-control">
                                <input type="text" id="profileNameInput" class="input-compact"
                                    style="width: 100%; max-width: 200px;">
                            </div>
                        </div>

                        <div class="setting-item">
                            <span class="setting-label">Unit√† di misura</span>
                            <div class="setting-control">
                                <select class="input-compact" style="width: 100%; max-width: 200px;">
                                    <option>Metrico (kg/cm)</option>
                                    <option>Imperiale (lbs/in)</option>
                                </select>
                            </div>
                        </div>

                        <!-- AI CONFIG SECTION -->
                        <div class="setting-item">
                            <div style="width: 100%; display: flex; flex-direction: column; gap: 0.5rem;">
                                <div style="display: flex; justify-content: space-between; align-items: center;">
                                    <span class="setting-label">Gemini AI Key</span>
                                    <a href="https://aistudio.google.com/app/apikey" target="_blank"
                                        style="font-size: 0.75rem; color: var(--color-primary); text-decoration: underline;">Ottieni
                                        Key</a>
                                </div>
                                <form style="display: flex; gap: 0.5rem; width: 100%;" onsubmit="return false;">
                                    <input type="password" id="aiKeyInput" placeholder="Incolla qui la tua API Key"
                                        autocomplete="off" class="input-compact" style="flex: 1;">
                                    <button id="saveAiKeyBtn" type="button"
                                        class="btn btn-outline btn-compact">Salva</button>
                                </form>
                                <p id="aiKeyStatus"
                                    style="font-size: 0.7rem; color: var(--color-text-muted); text-align: right; margin: 0; min-height: 1em;">
                                </p>
                            </div>
                        </div>

                        <!-- IMGBB CONFIG SECTION -->
                        <div class="setting-item">
                            <div style="width: 100%; display: flex; flex-direction: column; gap: 0.5rem;">
                                <div style="display: flex; justify-content: space-between; align-items: center;">
                                    <span class="setting-label">ImgBB API Key</span>
                                    <a href="https://api.imgbb.com/" target="_blank"
                                        style="font-size: 0.75rem; color: var(--color-primary); text-decoration: underline;">Ottieni
                                        Key</a>
                                </div>
                                <form style="display: flex; gap: 0.5rem; width: 100%;" onsubmit="return false;">
                                    <input type="password" id="imgbbKeyInput" placeholder="Incolla qui la tua API Key"
                                        autocomplete="off" class="input-compact" style="flex: 1;">
                                    <button id="saveImgbbKeyBtn" type="button"
                                        class="btn btn-outline btn-compact">Salva</button>
                                </form>
                                <p id="imgbbKeyStatus"
                                    style="font-size: 0.7rem; color: var(--color-text-muted); text-align: right; margin: 0; min-height: 1em;">
                                </p>
                            </div>
                        </div>

                        <!-- Health Connect Section -->
                        <div class="setting-item"
                            style="border-left: 3px solid var(--color-primary); padding-left: 1rem;">
                            <div style="display: flex; align-items: center; gap: 0.5rem; margin-bottom: 0.5rem;">
                                <span style="font-size: 1.5rem;">üè•</span>
                                <span class="setting-label" style="font-size: 1rem; font-weight: 600;">Connessione
                                    Salute</span>
                            </div>
                            <p
                                style="font-size: 0.85rem; color: var(--color-text-muted); margin-bottom: 1rem; line-height: 1.4;">
                                Sincronizza automaticamente i tuoi dati fitness per analisi AI pi√π complete.
                            </p>

                            <div id="healthConnectStatus"
                                style="margin-bottom: 1rem; padding: 0.75rem; background: rgba(255,255,255,0.03); border-radius: 8px;">
                                <p id="healthStatusText"
                                    style="font-size: 0.9rem; color: var(--color-text-muted); margin: 0;">
                                    Non connesso
                                </p>
                                <small id="healthLastSync"
                                    style="font-size: 0.75rem; color: var(--color-text-muted); display: none; margin-top: 0.25rem;">
                                    Ultimo sync: <span id="lastSyncTime"></span>
                                </small>
                            </div>

                            <!-- Provider Selection (shown when not connected) -->
                            <div id="healthProviderSelection" style="margin-bottom: 1rem;">
                                <p style="font-size: 0.8rem; color: var(--color-text-muted); margin-bottom: 0.75rem;">
                                    Scegli il tuo provider:
                                </p>
                                <div style="display: flex; gap: 0.5rem; flex-wrap: wrap;">
                                    <button id="connectGoogleFitBtn" class="btn btn-outline btn-compact"
                                        style="display: flex; align-items: center; gap: 6px; flex: 1; min-width: 140px; justify-content: center;">
                                        <span style="font-size: 1.2rem;">ü§ñ</span> Google Fit
                                        <small style="font-size: 0.65rem; opacity: 0.7;">(Android)</small>
                                    </button>
                                    <button id="connectAppleHealthBtn" class="btn btn-outline btn-compact"
                                        style="display: flex; align-items: center; gap: 6px; flex: 1; min-width: 140px; justify-content: center;">
                                        <span style="font-size: 1.2rem;">üçé</span> Apple Health
                                        <small style="font-size: 0.65rem; opacity: 0.7;">(iOS)</small>
                                    </button>
                                </div>
                            </div>

                            <!-- Connected Actions (shown when connected) -->
                            <div id="healthConnectedActions" style="display: none;">
                                <div style="display: flex; gap: 0.5rem; flex-wrap: wrap;">
                                    <button id="syncHealthBtn" class="btn btn-primary btn-compact"
                                        style="display: flex; align-items: center; gap: 6px;">
                                        <span>üîÑ</span> Sincronizza Ora
                                    </button>
                                    <button id="disconnectHealthBtn" class="btn btn-outline btn-compact"
                                        style="color: #ef4444; border-color: #ef4444;">
                                        <span>‚ùå</span> Disconnetti
                                    </button>
                                </div>
                            </div>
                        </div>

                        <div class="setting-item">
                            <div
                                style="display: flex; justify-content: space-between; align-items: center; width: 100%; flex-wrap: wrap; gap: 0.5rem;">
                                <span class="setting-label">Sincronizzazione</span>
                                <div class="setting-control" style="width: auto; justify-content: flex-end;">
                                    <button id="syncBtn" class="btn btn-outline btn-compact">Sincronizza Ora</button>
                                </div>
                            </div>
                            <p id="syncStatus"
                                style="font-size: 0.75rem; color: var(--color-text-muted); width: 100%; text-align: right; margin-top: 0.25rem;">
                            </p>
                        </div>

                        <div class="setting-item">
                            <span class="setting-label">Esporta Dati (JSON)</span>
                            <div class="setting-control">
                                <button id="exportBtn" class="btn btn-outline btn-compact">Download</button>
                            </div>
                        </div>

                        <div class="setting-item" style="border-bottom: none; margin-top: 1rem;">
                            <button id="logoutBtn" class="btn btn-primary"
                                style="width: 100%; background: #ff4444; border-color: #ff4444; color: white;">Esci</button>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </section>

    <!-- AI Plan History Modal -->
    <div id="aiPlanHistoryModal"
        style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.9); z-index: 2000; align-items: center; justify-content: center; padding: clamp(0.5rem, 2vw, 1rem); overflow-y: auto;">
        <div class="card"
            style="max-width: 500px; width: 100%; max-height: 90vh; overflow-y: auto; position: relative; margin: auto;">
            <button id="closeAiPlanHistory"
                style="position: sticky; top: 0; right: 0; float: right; background: rgba(0,0,0,0.5); border: 1px solid rgba(255,255,255,0.2); color: white; font-size: 1.5rem; cursor: pointer; width: 36px; height: 36px; border-radius: 50%; display: flex; align-items: center; justify-content: center; z-index: 10; margin-bottom: -36px;">&times;</button>
            <h3 style="margin-bottom: 1rem; font-size: clamp(1.1rem, 4vw, 1.3rem); padding-right: 40px;">Storico
                Sessioni <span class="text-primary">AI</span></h3>
            <div id="aiPlanHistoryList" style="display: flex; flex-direction: column; gap: 0.75rem;">
                <!-- history items -->
            </div>
        </div>
    </div>

    <!-- Wellness Prompt Modal -->
    <div id="wellnessPromptModal" class="wellness-modal" role="dialog" aria-modal="true"
        aria-labelledby="wellnessPromptTitle" style="display:none;">
        <div class="card wellness-modal-card">
            <h3 id="wellnessPromptTitle" style="margin-bottom:0.5rem;">Come ti senti oggi?</h3>
            <p style="color: var(--color-text-muted); font-size:0.85rem; margin-bottom:1rem;">Valuta il tuo stato prima
                di iniziare la sessione. Scala 1‚Äë10.</p>
            <form id="wellnessForm" style="display:flex; flex-direction:column; gap:0.75rem;">
                <label>Qualit√† del Sonno
                    <input type="number" id="sleepQualityInput" min="1" max="10" value="7" required
                        class="input-compact" style="width:100%;">
                </label>
                <label>Energia / Vigore Attuale
                    <input type="number" id="energyLevelInput" min="1" max="10" value="7" required class="input-compact"
                        style="width:100%;">
                </label>
                <label>Stress percepito
                    <input type="number" id="stressLevelInput" min="1" max="10" value="4" required class="input-compact"
                        style="width:100%;">
                </label>
                <label>Dolore Muscolare / DOMS
                    <input type="number" id="sorenessLevelInput" min="1" max="10" value="3" required
                        class="input-compact" style="width:100%;">
                </label>
                <label>Gruppi Muscolari con DOMS
                    <span
                        style="display:block; font-size:0.75rem; color:var(--color-text-muted); margin-top:0.25rem;">Seleziona
                        uno o pi√π distretti che senti ancora doloranti per guidare il monitoraggio del recupero.</span>
                    <div id="sorenessMusclePicker" class="doms-chip-grid" role="listbox" aria-multiselectable="true">
                    </div>
                </label>
                <div class="doms-chip-info">
                    <small id="sorenessMuscleHint">Nessun distretto selezionato</small>
                    <button type="button" id="clearSorenessSelection" class="link-btn"
                        style="font-size:0.75rem;">Azzera</button>
                </div>
                <label style="margin-top: 0.75rem;">Causa DOMS / Dolore (opzionale)
                    <span style="display:block; font-size:0.75rem; color:var(--color-text-muted); margin-top:0.25rem;">
                        Se il dolore √® dovuto ad attivit√† esterne (es. Padel, corsa, lavoro fisico), specificalo qui.
                    </span>
                    <input type="text" id="domsExternalCauseInput" class="input-compact" style="width:100%; margin-top:0.5rem;"
                        placeholder="es. Partita di Padel ieri, Trasloco, Corsa 10km...">
                </label>
                <div style="display:flex; gap:0.75rem; margin-top:0.5rem;">
                    <button type="button" id="cancelWellnessBtn" class="btn btn-outline"
                        style="flex:1;">Annulla</button>
                    <button type="submit" class="btn btn-primary" style="flex:1;">Inizia Focus Mode</button>
                </div>
            </form>
        </div>
    </div>

    <!-- Focus Mode Overlay -->
    <div id="focusModeOverlay"
        style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: #000; z-index: 2000; flex-direction: column; padding: 1.5rem;">
        <!-- Top Bar -->
        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 1rem;">
            <div style="display:flex; flex-direction:column;">
                <div style="font-family: var(--font-display); font-size: 1.2rem; color: var(--color-primary);">FOCUS
                    FLOW</div>
                <div id="focusWorkoutTitle" style="font-size: 0.8rem; color: var(--color-text-muted);">Workout</div>
            </div>
            <button id="exitFocusMode"
                style="background: none; border: 1px solid #333; color: #fff; width: 40px; height: 40px; border-radius: 50%; font-size: 1.2rem; cursor: pointer;">‚úï</button>
        </div>

        <!-- Main Content -->
        <div
            style="flex: 1; display: flex; flex-direction: column; align-items: center; justify-content: center; width: 100%; max-width: 500px; margin: 0 auto;">

            <!-- Exercise Info -->
            <div style="text-align: center; margin-bottom: 2rem; width: 100%;">
                <h2 id="focusExerciseName" style="font-size: 2rem; margin-bottom: 0.5rem; line-height: 1.1;">Esercizio
                </h2>
                <div
                    style="font-size: 1.1rem; color: var(--color-text-muted); display: flex; justify-content: center; gap: 1rem;">
                    <span id="focusSetCounter">Set 1 / 3</span>
                </div>
            </div>

            <!-- Active Inputs Area -->
            <div id="focusActiveArea" style="width: 100%; margin-bottom: 2rem;">
                <!-- Bilateral Dumbbell Indicator -->
                <div id="focusBilateralIndicator" style="display: none; background: linear-gradient(135deg, rgba(156,39,176,0.15), rgba(103,58,183,0.1)); border: 1px solid rgba(156,39,176,0.3); border-radius: var(--radius-md); padding: 0.5rem 1rem; margin-bottom: 0.75rem; text-align: center;">
                    <div style="display: flex; align-items: center; justify-content: center; gap: 0.5rem;">
                        <span style="font-size: 1rem;">üèãÔ∏è</span>
                        <span style="color: #ce93d8; font-size: 0.8rem; font-weight: 500;">Manubri Bilaterali</span>
                        <span style="color: var(--color-text-muted); font-size: 0.7rem;">‚Ä¢ Inserisci peso singolo manubrio</span>
                    </div>
                </div>
                <!-- Suggested Weight Banner -->
                <div id="focusSuggestedWeight" style="display: none; background: linear-gradient(135deg, rgba(0,243,255,0.15), rgba(0,153,255,0.1)); border: 1px solid rgba(0,243,255,0.3); border-radius: var(--radius-md); padding: 0.6rem 1rem; margin-bottom: 1rem; text-align: center;">
                    <div style="display: flex; align-items: center; justify-content: center; gap: 0.5rem; flex-wrap: wrap;">
                        <span style="color: var(--color-text-muted); font-size: 0.75rem;">üí° Suggerito:</span>
                        <span id="focusSuggestedValue" style="color: var(--color-primary); font-weight: bold; font-size: 1.1rem;">--</span>
                        <span style="color: var(--color-text-muted); font-size: 0.7rem;" id="focusSuggestedBasis">(basato su storico)</span>
                    </div>
                </div>
                <div style="display: grid; grid-template-columns: 1fr 1fr 1fr; gap: 0.75rem; margin-bottom: 1.5rem;">
                    <div
                        style="background: var(--color-surface); padding: 0.75rem 0.5rem; border-radius: var(--radius-md); border: 1px solid var(--color-border); text-align: center;">
                        <label id="focusWeightLabel"
                            style="display: block; color: var(--color-text-muted); font-size: 0.7rem; margin-bottom: 0.3rem;">KG</label>
                        <input type="number" id="focusWeightInput"
                            style="width: 100%; background: transparent; border: none; color: white; font-size: 2rem; text-align: center; font-weight: bold; font-family: var(--font-display);"
                            value="">
                    </div>
                    <div
                        style="background: var(--color-surface); padding: 0.75rem 0.5rem; border-radius: var(--radius-md); border: 1px solid var(--color-border); text-align: center;">
                        <label
                            style="display: block; color: var(--color-text-muted); font-size: 0.7rem; margin-bottom: 0.3rem;">REPS</label>
                        <input type="text" id="focusRepsInput"
                            style="width: 100%; background: transparent; border: none; color: white; font-size: 2rem; text-align: center; font-weight: bold; font-family: var(--font-display);"
                            value="">
                    </div>
                    <div
                        style="background: var(--color-surface); padding: 0.75rem 0.5rem; border-radius: var(--radius-md); border: 1px solid var(--color-border); text-align: center;">
                        <label
                            style="display: block; color: var(--color-text-muted); font-size: 0.7rem; margin-bottom: 0.3rem;">RPE</label>
                        <input type="number" id="focusRpeInput" min="1" max="10" step="0.5"
                            style="width: 100%; background: transparent; border: none; color: white; font-size: 2rem; text-align: center; font-weight: bold; font-family: var(--font-display);"
                            value="" placeholder="1-10">
                    </div>
                </div>
            </div>

            <!-- Timer Area (Hidden by default) -->
            <div id="focusTimerArea" style="display: none; text-align: center; margin-bottom: 2rem; width: 100%;">
                <div style="color: var(--color-text-muted); margin-bottom: 0.5rem;">RECUPERO</div>
                <div id="focusTimer"
                    style="font-family: monospace; font-size: 4.5rem; color: white; line-height: 1; margin-bottom: 1rem;">
                    00:00</div>
                <div style="display: flex; gap: 1rem; justify-content: center;">
                    <button class="btn-timer-adjust" onclick="adjustTimer(-10)">-10s</button>
                    <button class="btn-timer-adjust" onclick="adjustTimer(+10)">+10s</button>
                    <button class="btn-timer-adjust" onclick="skipRest()">Salta</button>
                </div>
            </div>

            <!-- Action Button -->
            <button id="focusActionBtn" class="btn btn-primary"
                style="width: 100%; height: 70px; font-size: 1.4rem; border-radius: 12px; box-shadow: 0 4px 20px rgba(0, 243, 255, 0.3); text-transform: uppercase; letter-spacing: 1px; font-weight: bold;">
                FATTO
            </button>

            <!-- Log History for Current Exercise -->
            <div id="focusHistoryList"
                style="margin-top: 2rem; width: 100%; max-height: 100px; overflow-y: auto; font-size: 0.8rem; color: #666; text-align: left; border-top: 1px solid #222; padding-top: 1rem;">
                <!-- Previous sets show here -->
            </div>

        </div>

        <!-- Next Exercise Preview -->
        <div id="nextExercisePreview" style="display: none; margin-top: 1rem; width: 100%; padding: 0.75rem; background: rgba(0, 243, 255, 0.05); border: 1px solid rgba(0, 243, 255, 0.15); border-radius: 8px;">
            <div style="display: flex; align-items: center; gap: 0.5rem;">
                <span style="font-size: 0.7rem; color: var(--color-text-muted); text-transform: uppercase; letter-spacing: 0.05em;">Prossimo</span>
                <span style="flex: 1; height: 1px; background: rgba(255,255,255,0.1);"></span>
            </div>
            <div style="display: flex; align-items: center; justify-content: space-between; margin-top: 0.5rem;">
                <span id="nextExerciseName" style="font-size: 0.95rem; color: var(--color-primary); font-weight: 500;">‚Äî</span>
                <span id="nextExerciseSets" style="font-size: 0.75rem; color: var(--color-text-muted);">‚Äî serie</span>
            </div>
        </div>

        <!-- Bottom Progress -->
        <div style="margin-top: auto; width: 100%;">
            <div
                style="display: flex; justify-content: space-between; margin-bottom: 0.5rem; font-size: 0.8rem; color: #666;">
                <span>Progresso</span>
                <span id="focusProgressText">0%</span>
            </div>
            <div style="height: 6px; background: #222; border-radius: 3px; overflow: hidden;">
                <div id="focusProgressBar"
                    style="height: 100%; width: 0%; background: var(--color-primary); transition: width 0.3s ease;">
                </div>
            </div>
        </div>
    </div>

    <style>
        .btn-timer-adjust {
            background: rgba(255, 255, 255, 0.1);
            border: none;
            color: white;
            padding: 0.5rem 1rem;
            border-radius: 20px;
            cursor: pointer;
        }

        .btn-timer-adjust:hover {
            background: rgba(255, 255, 255, 0.2);
        }
    </style>

    <script src="js/main.js"></script>

    <!-- Share Modal -->
    <div id="shareModal"
        style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.8); z-index: 10000; justify-content: center; align-items: center;">
        <div
            style="background: var(--color-surface); padding: 2rem; border-radius: 12px; width: 90%; max-width: 400px; text-align: center; border: 1px solid var(--color-border);">
            <h3 style="margin-bottom: 1.5rem;">Condividi Scheda</h3>

            <div style="display: grid; grid-template-columns: 1fr 1fr 1fr; gap: 1rem; margin-bottom: 1.5rem;">
                <button id="shareNative"
                    style="display: flex; flex-direction: column; align-items: center; gap: 0.5rem; border: none; color: white; padding: 1rem; background: linear-gradient(135deg, #00f3ff, #0099ff); border-radius: 8px; cursor: pointer; font-family: inherit;">
                    <span style="font-size: 2rem;">ÔøΩ</sppan>
                    <span>Condividi</span>
                </button>
                <a id="shareWhatsapp" href="#" target="_blank"
                    style="display: flex; flex-direction: column; align-items: center; gap: 0.5rem; text-decoration: none; color: white; padding: 1rem; background: #25D366; border-radius: 8px;">
                    <span style="font-size: 2rem;">üíö</span>
                    <span>WhatsApp</span>
                </a>
                <a id="shareTelegram" href="#" target="_blank"
                    style="display: flex; flex-direction: column; align-items: center; gap: 0.5rem; text-decoration: none; color: white; padding: 1rem; background: #0088cc; border-radius: 8px;">
                    <span style="font-size: 2rem;">‚úàÔ∏è</span>
                    <span>Telegram</span>
                </a>
                <a id="shareTwitter" href="#" target="_blank"
                    style="display: flex; flex-direction: column; align-items: center; gap: 0.5rem; text-decoration: none; color: white; padding: 1rem; background: #1DA1F2; border-radius: 8px;">
                    <span style="font-size: 2rem;">ÔøΩ</sppan>
                    <span>X/Twitter</span>
                </a>
                <a id="shareFacebook" href="#" target="_blank"
                    style="display: flex; flex-direction: column; align-items: center; gap: 0.5rem; text-decoration: none; color: white; padding: 1rem; background: #1877F2; border-radius: 8px;">
                    <span style="font-size: 2rem;">üìò</span>
                    <span>Facebook</span>
                </a>
                <a id="shareEmail" href="#" target="_blank"
                    style="display: flex; flex-direction: column; align-items: center; gap: 0.5rem; text-decoration: none; color: white; padding: 1rem; background: #666; border-radius: 8px;">
                    <span style="font-size: 2rem;">üìß</span>
                    <span>Email</span>
                </a>
                <button id="shareCopy"
                    style="display: flex; flex-direction: column; align-items: center; gap: 0.5rem; border: none; color: white; padding: 1rem; background: rgba(255,255,255,0.1); border-radius: 8px; cursor: pointer; font-family: inherit; grid-column: span 3;">
                    <span style="font-size: 2rem;">üìã</span>
                    <span>Copia Link</span>
                </button>
            </div>

            <button id="closeShareModal" class="btn btn-outline" style="width: 100%;">Chiudi</button>
        </div>
    </div>

    <!-- Module Script for Firebase Logic -->
    <script type="module">
        import { authService } from './js/auth-service.js';
        import { firestoreService } from './js/firestore-service.js';
        import { aiService } from './js/ai-service.js';
        import { EXERCISE_DB, MUSCLE_GROUPS, isBilateralDumbbell, calculateTotalWeight } from './js/exercise-db.js';
        import { notificationManager } from './js/notification-manager.js';

        document.addEventListener('DOMContentLoaded', () => {

            // Elements
            const authSection = document.getElementById('authSection');
            const profileContent = document.getElementById('profileContent');
            const authForm = document.getElementById('authForm');
            const authSwitchBtn = document.getElementById('authSwitchBtn');
            const nameGroup = document.getElementById('nameGroup');
            const authTitle = document.getElementById('authTitle');
            const authError = document.getElementById('authError');

            const profileAvatar = document.getElementById('profileAvatar');
            const avatarContainer = document.getElementById('avatarContainer');
            const photoInput = document.getElementById('photoInput');
            const profileNameDisplay = document.getElementById('profileNameDisplay');
            const profileEmailDisplay = document.getElementById('profileEmailDisplay');
            const profileNameInput = document.getElementById('profileNameInput');
            const logoutBtn = document.getElementById('logoutBtn');
            const syncBtn = document.getElementById('syncBtn');
            const syncStatus = document.getElementById('syncStatus');

            let isLoginMode = true;

            // --- Auth Logic ---

            // Switch between Login and Register
            authSwitchBtn.addEventListener('click', (e) => {
                e.preventDefault();
                isLoginMode = !isLoginMode;
                if (isLoginMode) {
                    authTitle.textContent = 'Accedi';
                    nameGroup.style.display = 'none';
                    authForm.querySelector('button[type="submit"]').textContent = 'Entra';
                    document.getElementById('authSwitchText').textContent = 'Non hai un account?';
                    authSwitchBtn.textContent = 'Registrati';
                } else {
                    authTitle.textContent = 'Registrati';
                    nameGroup.style.display = 'block';
                    authForm.querySelector('button[type="submit"]').textContent = 'Registrati';
                    document.getElementById('authSwitchText').textContent = 'Hai gi√† un account?';
                    authSwitchBtn.textContent = 'Accedi';
                }
            });

            // Handle Submit
            authForm.addEventListener('submit', async (e) => {
                e.preventDefault();
                authError.textContent = '';
                const email = document.getElementById('emailInput').value;
                const password = document.getElementById('passwordInput').value;
                const name = document.getElementById('nameInput').value;

                let result;
                if (isLoginMode) {
                    result = await authService.login(email, password);
                } else {
                    result = await authService.register(email, password, name);
                }

                if (!result.success) {
                    let msg = result.message;
                    if (msg.includes('auth/invalid-email')) msg = 'Email non valida.';
                    if (msg.includes('auth/wrong-password')) msg = 'Password errata.';
                    if (msg.includes('auth/user-not-found')) msg = 'Utente non trovato.';
                    if (msg.includes('auth/email-already-in-use')) msg = 'Email gi√† in uso.';
                    authError.textContent = msg;
                }
                // Success is handled by auth state listener
            });

            // Logout
            logoutBtn.addEventListener('click', async () => {
                await authService.logout();
                window.location.reload(); // Clean state
            });


            // --- State Management ---

            authService.subscribe(async (user) => {
                if (user) {
                    // Logged In
                    authSection.classList.remove('visible');
                    profileContent.classList.add('visible');

                    profileEmailDisplay.textContent = user.email;
                    profileNameDisplay.innerHTML = user.displayName || 'Atleta <span class="text-primary">Pro</span>';
                    profileNameInput.value = user.displayName || '';

                    // Load Profile Data from LocalStorage (or trigger sync)
                    const localProfile = JSON.parse(localStorage.getItem('ironflow_profile') || '{}');
                    if (localProfile.photoUrl) {
                        profileAvatar.style.backgroundImage = `url('${localProfile.photoUrl}')`;
                        profileAvatar.textContent = '';
                    } else {
                        // Fallback to user photoURL from Auth if exists
                        if (user.photoURL) {
                            profileAvatar.style.backgroundImage = `url('${user.photoURL}')`;
                            profileAvatar.textContent = '';
                        }
                    }

                    // Load Workouts from Cloud
                    syncStatus.textContent = 'Sincronizzazione...';
                    const loadResult = await firestoreService.loadFromCloud();

                    if (loadResult.success) {
                        syncStatus.textContent = 'Cloud Sincronizzato';
                        setTimeout(() => syncStatus.textContent = '', 2000);
                        if (loadResult.data) {
                            renderWorkouts();
                            
                            // Auto-restore Gemini API key from profile if local is empty
                            const cloudProfile = loadResult.data.profile || {};
                            if (cloudProfile.geminiKey && !aiService.hasKey()) {
                                console.log('üîë Auto-restoring Gemini API key from cloud profile...');
                                aiService.saveKey(cloudProfile.geminiKey);
                                const aiKeyInput = document.getElementById('aiKeyInput');
                                if (aiKeyInput) aiKeyInput.value = cloudProfile.geminiKey;
                            }
                            
                            // Auto-check and refresh Google Fit token if needed
                            try {
                                if (typeof healthConnectService !== 'undefined') {
                                    const healthStatus = await healthConnectService.getStatus();
                                    if (healthStatus.hasToken && !healthStatus.tokenValid) {
                                        console.log('üîÑ Google Fit token expired, attempting auto-refresh...');
                                        await healthConnectService.refreshAccessToken();
                                        console.log('‚úÖ Google Fit token refreshed successfully');
                                    }
                                }
                            } catch (healthError) {
                                console.warn('Could not auto-refresh Google Fit token:', healthError.message);
                            }
                            
                            // AI history is now automatically merged in loadFromCloud()
                            // Sync back to cloud to ensure both platforms have the merged history
                            const mergedAiHistory = JSON.parse(localStorage.getItem('ironflow_ai_plan_history') || '[]');
                            const cloudAiHistory = loadResult.data.aiPlanHistory || [];
                            if (mergedAiHistory.length !== cloudAiHistory.length) {
                                console.log('üìö AI history merged, syncing back to cloud...');
                                await firestoreService.syncToCloud();
                            }
                        }
                    }

                    // --- CHECK FOR SHARED WORKOUT IMPORT ---
                    const urlParams = new URLSearchParams(window.location.search);
                    const shareData = urlParams.get('shareData'); // New method
                    const shareId = urlParams.get('shareId'); // Fallback (Legacy)

                    if (shareData) {
                        if (confirm('√à stato rilevato un link di condivisione. Vuoi importare la scheda?')) {
                            try {
                                const json = decodeURIComponent(atob(shareData));
                                const newWorkout = JSON.parse(json);

                                // Validation
                                if (!newWorkout || !newWorkout.name || !Array.isArray(newWorkout.exercises)) {
                                    throw new Error("Dati scheda non validi");
                                }

                                // Assign new ID
                                newWorkout.id = generateWorkoutId();
                                newWorkout.name = `${newWorkout.name} (Importata)`;
                                newWorkout.fromShared = true;

                                const currentWorkouts = getStoredWorkouts();
                                currentWorkouts.unshift(newWorkout);
                                localStorage.setItem('ironflow_workouts', JSON.stringify(currentWorkouts));
                                renderWorkouts();

                                await firestoreService.syncToCloud();

                                window.history.replaceState({}, document.title, window.location.pathname);
                                alert(`Scheda "${newWorkout.name}" importata con successo!`);
                            } catch (e) {
                                console.error(e);
                                alert('Errore durante l\'importazione della scheda: link non valido.');
                            }
                        }
                    } else if (shareId) {
                        // Keep legacy support just in case
                        if (confirm('√à stato rilevato un link di condivisione (Legacy). Vuoi importare la scheda?')) {
                            const importResult = await firestoreService.getSharedWorkout(shareId);
                            if (importResult.success && importResult.data) {
                                const newWorkout = importResult.data.workoutData;
                                newWorkout.id = generateWorkoutId();
                                newWorkout.name = `${newWorkout.name} (Importata)`;
                                newWorkout.fromShared = true;

                                const currentWorkouts = getStoredWorkouts();
                                currentWorkouts.unshift(newWorkout);
                                localStorage.setItem('ironflow_workouts', JSON.stringify(currentWorkouts));
                                renderWorkouts();
                                await firestoreService.syncToCloud();

                                window.history.replaceState({}, document.title, window.location.pathname);
                                alert(`Scheda "${newWorkout.name}" importata con successo!`);
                            } else {
                                alert('Errore importazione: ' + (importResult.message || 'Scheda non valida'));
                            }
                        }
                    }

                } else {
                    // Not Logged In
                    authSection.classList.add('visible');
                    profileContent.classList.remove('visible');
                    // If share link present but not logged in, user will see auth form first
                    // Once logged in, this subscription runs again and handles the import
                }
            });


            // --- Profile Features ---

            // Photo Upload
            avatarContainer.addEventListener('click', () => photoInput.click());

            photoInput.addEventListener('change', async (e) => {
                if (e.target.files && e.target.files[0]) {
                    const file = e.target.files[0];

                    // Optimistic UI update
                    const reader = new FileReader();
                    reader.onload = (e) => {
                        profileAvatar.style.backgroundImage = `url('${e.target.result}')`;
                        profileAvatar.textContent = '';
                    }
                    reader.readAsDataURL(file);

                    syncStatus.textContent = 'Caricamento foto...';
                    const result = await firestoreService.uploadProfilePhoto(file);
                    if (result.success) {
                        syncStatus.textContent = 'Foto aggiornata!';
                    } else {
                        syncStatus.textContent = 'Errore caricamento foto';
                        alert('Errore: ' + result.message);
                    }
                }
            });

            // Name Update
            profileNameInput.addEventListener('change', async (e) => {
                const newName = e.target.value;
                profileNameDisplay.innerHTML = newName; // Immediate UI
                await firestoreService.updateProfileField('name', newName);
                await firestoreService.syncToCloud(); // Sync all
            });

            // Manual Sync
            syncBtn.addEventListener('click', async () => {
                syncStatus.textContent = 'Sync in corso...';
                await firestoreService.syncToCloud();
                syncStatus.textContent = 'Sincronizzato ora.';
                setTimeout(() => syncStatus.textContent = '', 2000);
            });

            // --- AI Predictor Logic ---
            const refreshAiPredictor = document.getElementById('refreshAiPredictor');
            const aiPlanHistoryBtn = document.getElementById('aiPlanHistoryBtn');
            const aiPlanHistoryModal = document.getElementById('aiPlanHistoryModal');
            const closeAiPlanHistory = document.getElementById('closeAiPlanHistory');
            const aiPlanHistoryList = document.getElementById('aiPlanHistoryList');
            const aiPredictorContent = document.getElementById('aiPredictorContent');

            const AI_PLAN_HISTORY_KEY = 'ironflow_ai_plan_history';
            let latestAiPlan = null;

            const loadAiPlanHistory = () => {
                try {
                    return JSON.parse(localStorage.getItem(AI_PLAN_HISTORY_KEY) || '[]');
                } catch (error) {
                    console.error('Errore lettura storico AI', error);
                    return [];
                }
            };

            const saveAiPlanHistory = async (plan) => {
                const history = loadAiPlanHistory();
                history.unshift(plan);
                const trimmed = history.slice(0, 20);
                localStorage.setItem(AI_PLAN_HISTORY_KEY, JSON.stringify(trimmed));
                
                // Sync to Firestore for persistence across devices
                try {
                    if (authService.getCurrentUser()) {
                        await firestoreService.syncToCloud();
                    }
                } catch (e) {
                    console.warn('Could not sync AI history to cloud:', e);
                }
            };

            const formatList = (items = []) => {
                if (!items) return '<li>Nessun suggerimento specificato</li>';
                const arr = Array.isArray(items) ? items : [items];
                if (!arr.length) return '<li>Nessun suggerimento specificato</li>';
                return arr.map(item => `<li>${item}</li>`).join('');
            };

            const renderAiPlan = (plan) => {
                latestAiPlan = plan;
                console.log('üìã renderAiPlan chiamato con:', JSON.stringify(plan, null, 2));
                const date = new Date(plan.createdAt || Date.now()).toLocaleString('it-IT', { day: 'numeric', month: 'short', hour: '2-digit', minute: '2-digit' });
                const isPersonalized = plan.isPersonalized || plan.aiPersonalized;
                const badgeHtml = isPersonalized 
                    ? '<span class="ai-badge" style="background: linear-gradient(135deg, rgba(0,243,255,0.3), rgba(156,39,176,0.3)); border-color: #9c27b0;">AI+</span>'
                    : '<span class="ai-badge">AI</span>';
                
                // Supporta sia il formato nuovo (exercises) che legacy (warmup/main_lifts)
                // PRIORIT√Ä: exercises > warmup/main_lifts
                const exercises = plan.exercises;
                const hasExercises = exercises && Array.isArray(exercises) && exercises.length > 0;
                const warmupArr = plan.warmup && Array.isArray(plan.warmup) ? plan.warmup : [];
                const mainLiftsArr = plan.main_lifts && Array.isArray(plan.main_lifts) ? plan.main_lifts : [];
                const hasLegacyFormat = warmupArr.length > 0 || mainLiftsArr.length > 0;
                
                console.log('üìã Plan data:', { 
                    exercises: exercises, 
                    hasExercises: hasExercises, 
                    warmup: plan.warmup, 
                    main_lifts: plan.main_lifts,
                    hasLegacyFormat: hasLegacyFormat 
                });
                
                let exercisesHtml = '';
                if (hasExercises) {
                    // Nuovo formato: exercises √® un array di oggetti {name, sets, reps, notes}
                    exercisesHtml = `
                        <div class="ai-plan-section">
                            <h5>Esercizi Suggeriti</h5>
                            <ul>
                                ${exercises.map(ex => {
                                    const name = ex.name || ex.exercise || 'Esercizio';
                                    const details = [];
                                    if (ex.sets) details.push(`${ex.sets} serie`);
                                    if (ex.reps) details.push(`${ex.reps} reps`);
                                    const detailStr = details.length ? ` (${details.join(' x ')})` : '';
                                    const notesStr = ex.notes ? `<br><small style="color: var(--color-text-muted);">${ex.notes}</small>` : '';
                                    return `<li><strong>${name}</strong>${detailStr}${notesStr}</li>`;
                                }).join('')}
                            </ul>
                        </div>
                    `;
                } else if (hasLegacyFormat) {
                    // Formato legacy: warmup e main_lifts sono array di stringhe
                    exercisesHtml = `
                        ${warmupArr.length > 0 ? `
                        <div class="ai-plan-section">
                            <h5>Warmup</h5>
                            <ul>${formatList(warmupArr)}</ul>
                        </div>` : ''}
                        ${mainLiftsArr.length > 0 ? `
                        <div class="ai-plan-section">
                            <h5>Main Lifts</h5>
                            <ul>${formatList(mainLiftsArr)}</ul>
                        </div>` : ''}
                    `;
                } else {
                    // Nessun formato riconosciuto - mostra messaggio di debug
                    exercisesHtml = `
                        <div class="ai-plan-section">
                            <p style="color: var(--color-text-muted);">‚ö†Ô∏è Formato dati non riconosciuto. Controlla la console per debug.</p>
                            <small style="color: #666;">Keys disponibili: ${Object.keys(plan).join(', ')}</small>
                        </div>
                    `;
                }
                
                // Mostra reasoning se disponibile
                const reasoningHtml = plan.reasoning ? `
                    <div class="ai-plan-section" style="margin-top: 0.5rem; padding: 0.5rem; background: rgba(0,243,255,0.05); border-radius: 6px;">
                        <small style="color: var(--color-text-muted);"><strong>üí° Ragionamento:</strong> ${plan.reasoning}</small>
                    </div>
                ` : '';
                
                aiPredictorContent.innerHTML = `
                    <div class="ai-plan-card">
                        <div style="display:flex; justify-content: space-between; align-items: center; gap: 0.5rem;">
                            <div>
                                <h4 style="margin:0;">${plan.suggestion || 'Allenamento AI'}</h4>
                                <small style="color: var(--color-text-muted);">${date}</small>
                            </div>
                            ${badgeHtml}
                        </div>
                        <p style="margin: 0.75rem 0; color: #ddd;">${plan.focus || ''}</p>
                        ${exercisesHtml}
                        ${reasoningHtml}
                        <div style="margin-top: 1rem; display: flex; gap: 0.5rem;">
                            <button id="saveAiPlanBtn" class="btn btn-primary" style="flex:1;">Salva come scheda</button>
                        </div>
                    </div>
                `;

                const saveBtn = document.getElementById('saveAiPlanBtn');
                if (saveBtn) {
                    saveBtn.addEventListener('click', () => handleAiPlanSave(plan, saveBtn));
                }
            };

            const handleAiPlanSave = async (plan, buttonEl) => {
                if (!plan) return;
                buttonEl.disabled = true;
                buttonEl.textContent = 'Salvataggio...';

                const workouts = getStoredWorkouts();
                
                // Supporta sia il formato nuovo (exercises) che legacy (main_lifts/warmup)
                let exercisesForWorkout = [];
                if (plan.exercises && Array.isArray(plan.exercises) && plan.exercises.length > 0) {
                    // Nuovo formato: exercises √® gi√† un array di oggetti
                    exercisesForWorkout = plan.exercises.map(ex => ({
                        name: ex.name || 'Esercizio',
                        sets: ex.sets || '4',
                        reps: ex.reps || '8-10',
                        notes: ex.notes || ''
                    }));
                } else if (plan.main_lifts && Array.isArray(plan.main_lifts)) {
                    // Formato legacy: main_lifts √® un array di stringhe
                    exercisesForWorkout = plan.main_lifts.map((lift, idx) => ({
                        name: lift,
                        sets: '4',
                        reps: '8-10',
                        notes: idx < (plan.warmup || []).length ? `Warmup: ${(plan.warmup || [])[idx]}` : ''
                    }));
                }
                
                const newWorkout = {
                    id: generateWorkoutId(),
                    name: plan.suggestion || `Sessione AI ${new Date().toLocaleDateString('it-IT')}`,
                    description: plan.focus || 'Allenamento generato da Gemini AI',
                    exercises: exercisesForWorkout,
                    warmup: plan.warmup,
                    fromAI: true,
                    aiMeta: {
                        focus: plan.focus,
                        reasoning: plan.reasoning,
                        createdAt: plan.createdAt || new Date().toISOString(),
                        source: 'predictor'
                    },
                    dateCreated: new Date().toISOString()
                };

                workouts.push(newWorkout);
                localStorage.setItem('ironflow_workouts', JSON.stringify(workouts));
                renderWorkouts();

                try {
                    await firestoreService.syncToCloud();
                } catch (error) {
                    console.warn('Sync scheda AI fallita:', error.message || error);
                }

                buttonEl.textContent = 'Salvata!';
            };

            const renderAiPlanHistoryList = async (forceRefresh = false) => {
                // Show loading state
                aiPlanHistoryList.innerHTML = '<p style="color: var(--color-text-muted); text-align: center;"><span class="loading-spinner"></span> Sincronizzazione...</p>';
                
                // Refresh from cloud if user is logged in
                if (forceRefresh && authService.getCurrentUser()) {
                    try {
                        const loadResult = await firestoreService.loadFromCloud();
                        if (loadResult.success && loadResult.data) {
                            // Merge is handled automatically in loadFromCloud
                            console.log('üìö Storico AI aggiornato dal cloud');
                        }
                    } catch (e) {
                        console.warn('Could not refresh AI history from cloud:', e);
                    }
                }
                
                const history = loadAiPlanHistory();
                if (!history.length) {
                    aiPlanHistoryList.innerHTML = '<p style="color: var(--color-text-muted); text-align: center;">Nessuna sessione AI salvata.</p>';
                    return;
                }

                aiPlanHistoryList.innerHTML = '';
                history.forEach((plan, index) => {
                    const date = new Date(plan.createdAt || Date.now()).toLocaleString('it-IT', { day: '2-digit', month: 'short', hour: '2-digit', minute: '2-digit' });
                    const isPersonalized = plan.isPersonalized || plan.aiPersonalized;
                    const badgeHtml = isPersonalized 
                        ? '<span class="ai-badge" style="background: linear-gradient(135deg, rgba(0,243,255,0.3), rgba(156,39,176,0.3)); border-color: #9c27b0;">AI+</span>'
                        : '<span class="ai-badge">AI</span>';
                    const div = document.createElement('div');
                    div.style.cssText = 'padding: 0.75rem; border: 1px solid rgba(255,255,255,0.1); border-radius: 6px; cursor: pointer; background: rgba(255,255,255,0.02);';
                    div.innerHTML = `
                        <div style="display:flex; justify-content: space-between; align-items:center; gap:0.5rem;">
                            <div>
                                <strong>${plan.suggestion || 'Allenamento AI'}</strong>
                                <div style="font-size:0.75rem; color: var(--color-text-muted);">${date}</div>
                            </div>
                            ${badgeHtml}
                        </div>
                        <p style="font-size: 0.8rem; color: #ccc; margin: 0.5rem 0 0;">${plan.focus || ''}</p>
                    `;
                    div.addEventListener('click', () => {
                        renderAiPlan(plan);
                        aiPlanHistoryModal.style.display = 'none';
                    });
                    aiPlanHistoryList.appendChild(div);
                });
            };

            if (refreshAiPredictor) {
                refreshAiPredictor.addEventListener('click', async () => {
                    if (!aiService.hasKey()) {
                        aiPredictorContent.innerHTML = '<p style="color: #ff4444;">Imposta prima la tua API Key.</p>';
                        return;
                    }

                    aiPredictorContent.innerHTML = '<p style="color: var(--color-text-muted);">Generazione allenamento in corso...</p>';

                    const data = await firestoreService.gatherDataForAI();
                    const result = await aiService.predictNextSession(data);

                    if (result.success) {
                        const plan = {
                            ...result.data,
                            isPersonalized: false, // AI classico senza personalizzazione
                            createdAt: new Date().toISOString()
                        };
                        saveAiPlanHistory(plan);
                        renderAiPlan(plan);
                    } else {
                        aiPredictorContent.innerHTML = `<p style="color: #ff4444;">Errore: ${result.message}</p>`;
                    }
                });
            }

            // --- ImgBB Key Logic ---
            const imgbbKeyInput = document.getElementById('imgbbKeyInput');
            const saveImgbbKeyBtn = document.getElementById('saveImgbbKeyBtn');
            const imgbbKeyStatus = document.getElementById('imgbbKeyStatus');

            // Load Key
            const loadImgbbKey = async () => {
                const key = await firestoreService.getImgBBKey();
                if (key) {
                    imgbbKeyInput.value = key;
                    imgbbKeyStatus.textContent = 'Key salvata';
                }
            };
            // Call load only if elements exist (user might be logged out initially, but this runs on DOMContentLoaded)
            if (imgbbKeyInput) loadImgbbKey();

            // Save Key
            if (saveImgbbKeyBtn) {
                saveImgbbKeyBtn.addEventListener('click', async () => {
                    const key = imgbbKeyInput.value.trim();
                    if (!key) return;

                    saveImgbbKeyBtn.disabled = true;
                    saveImgbbKeyBtn.textContent = '...';

                    const result = await firestoreService.setImgBBKey(key);

                    saveImgbbKeyBtn.disabled = false;
                    saveImgbbKeyBtn.textContent = 'Salva';

                    if (result.success) {
                        imgbbKeyStatus.textContent = 'Key salvata con successo!';
                        imgbbKeyStatus.style.color = 'var(--color-primary)';
                        setTimeout(() => imgbbKeyStatus.textContent = '', 3000);
                    } else {
                        imgbbKeyStatus.textContent = 'Errore: ' + result.message;
                        imgbbKeyStatus.style.color = '#ff4444';
                    }
                });
            }

            if (aiPlanHistoryBtn) {
                aiPlanHistoryBtn.addEventListener('click', async () => {
                    aiPlanHistoryModal.style.display = 'flex';
                    await renderAiPlanHistoryList(true); // Force refresh from cloud
                });
            }

            if (closeAiPlanHistory) {
                closeAiPlanHistory.addEventListener('click', () => {
                    aiPlanHistoryModal.style.display = 'none';
                });
            }

            window.addEventListener('click', (e) => {
                if (e.target === aiPlanHistoryModal) {
                    aiPlanHistoryModal.style.display = 'none';
                }
            });

            // --- FOCUS MODE LOGIC ---
            const focusOverlay = document.getElementById('focusModeOverlay');
            const exitFocusModeBtn = document.getElementById('exitFocusMode');
            const focusActionBtn = document.getElementById('focusActionBtn');

            // New Elements
            const focusTimer = document.getElementById('focusTimer');
            const focusTimerArea = document.getElementById('focusTimerArea');
            const focusActiveArea = document.getElementById('focusActiveArea');
            const focusWeightInput = document.getElementById('focusWeightInput');
            const focusRepsInput = document.getElementById('focusRepsInput');
            const focusRpeInput = document.getElementById('focusRpeInput');
            const focusHistoryList = document.getElementById('focusHistoryList');
            const focusExerciseName = document.getElementById('focusExerciseName');
            const focusSetCounter = document.getElementById('focusSetCounter');
            const focusWorkoutTitle = document.getElementById('focusWorkoutTitle');
            const focusProgressBar = document.getElementById('focusProgressBar');
            const focusProgressText = document.getElementById('focusProgressText');
            const focusSuggestedWeight = document.getElementById('focusSuggestedWeight');
            const focusSuggestedValue = document.getElementById('focusSuggestedValue');
            const focusSuggestedBasis = document.getElementById('focusSuggestedBasis');
            const wellnessModal = document.getElementById('wellnessPromptModal');
            const wellnessForm = document.getElementById('wellnessForm');
            const cancelWellnessBtn = document.getElementById('cancelWellnessBtn');
            const sleepQualityInput = document.getElementById('sleepQualityInput');
            const energyLevelInput = document.getElementById('energyLevelInput');
            const stressLevelInput = document.getElementById('stressLevelInput');
            const sorenessLevelInput = document.getElementById('sorenessLevelInput');
            const sorenessMusclePicker = document.getElementById('sorenessMusclePicker');
            const sorenessMuscleHint = document.getElementById('sorenessMuscleHint');
            const clearSorenessSelectionBtn = document.getElementById('clearSorenessSelection');

            let currentWorkout = null;
            let currentExerciseIndex = 0;
            let currentSetIndex = 0;
            let isResting = false;
            let timerInterval = null;
            let remainingTime = 0;
            let currentWorkoutId = null;
            let sessionCompleted = false;
            let sessionStartTime = null;
            let sessionLogSaved = false;
            let pendingFocusWorkout = null;
            let currentWellnessSnapshot = null;
            
            // --- WEIGHT SUGGESTION SYSTEM ---
            // Cache delle stime 1RM calcolate dai log storici
            let exerciseEstimates = {};
            
            // Formula ibrida per calcolare 1RM (stessa usata in analysis.html)
            const calculateHybrid1RM = (weight, reps) => {
                if (reps === 1) return weight;
                if (reps > 15) return null;
                const epley = weight * (1 + reps / 30);
                const brzycki = weight * (36 / (37 - reps));
                const lombardi = weight * Math.pow(reps, 0.1);
                const mayhew = weight * (100 / (52.2 + 41.9 * Math.exp(-0.055 * reps)));
                const wathen = weight * (100 / (48.8 + 53.8 * Math.exp(-0.075 * reps)));
                return (epley * 0.25 + brzycki * 0.25 + lombardi * 0.15 + mayhew * 0.15 + wathen * 0.2);
            };
            
            // Percentuali NSCA per convertire 1RM in peso per X reps
            const rmPercentages = {
                1: 1.00, 2: 0.97, 3: 0.93, 4: 0.90, 5: 0.87,
                6: 0.85, 7: 0.83, 8: 0.80, 9: 0.77, 10: 0.75,
                11: 0.73, 12: 0.70, 13: 0.68, 14: 0.66, 15: 0.64
            };
            
            // Normalizza nome esercizio per matching (versione aggressiva)
            const normalizeExerciseName = (name) => {
                return (name || '').toLowerCase().trim()
                    .replace(/\s+/g, ' ')
                    .replace(/[√†√°√¢√£]/g, 'a')
                    .replace(/[√®√©√™√´]/g, 'e')
                    .replace(/[√¨√≠√Æ√Ø]/g, 'i')
                    .replace(/[√≤√≥√¥√µ]/g, 'o')
                    .replace(/[√π√∫√ª√º]/g, 'u')
                    .replace(/\(.*?\)/g, '') // Rimuove contenuto tra parentesi
                    .replace(/[:;,\-‚Äì]/g, ' ') // Rimuove punteggiatura
                    .replace(/\s+/g, ' ')
                    .trim();
            };
            
            // Trova i muscoli target di un esercizio
            const getExerciseMuscles = (exerciseName) => {
                const name = normalizeExerciseName(exerciseName);
                
                // Cerca match esatto in EXERCISE_DB
                for (const [exName, muscles] of Object.entries(EXERCISE_DB)) {
                    if (name === normalizeExerciseName(exName)) {
                        return { muscles, primaryMuscle: muscles[0], matchType: 'exact' };
                    }
                }
                
                // Cerca match parziale (contiene)
                for (const [exName, muscles] of Object.entries(EXERCISE_DB)) {
                    const normalizedDbName = normalizeExerciseName(exName);
                    if (name.includes(normalizedDbName) || normalizedDbName.includes(name)) {
                        return { muscles, primaryMuscle: muscles[0], matchType: 'partial' };
                    }
                }
                
                // Cerca per keyword comuni
                const keywords = {
                    'panca': 'chest', 'bench': 'chest', 'push': 'chest', 'chest': 'chest',
                    'traz': 'lats', 'pull': 'lats', 'lat': 'lats', 'row': 'lats', 'remator': 'lats',
                    'squat': 'quads', 'pressa': 'quads', 'leg': 'quads', 'affond': 'quads',
                    'stacco': 'hamstrings', 'deadlift': 'hamstrings',
                    'curl': 'biceps', 'bicip': 'biceps',
                    'tricip': 'triceps', 'french': 'triceps', 'pushdown': 'triceps',
                    'spall': 'front-delts', 'shoulder': 'front-delts', 'military': 'front-delts', 'lento': 'front-delts',
                    'lateral': 'side-delts', 'alzate': 'side-delts',
                    'crunch': 'abs', 'plank': 'abs', 'addominali': 'abs'
                };
                
                for (const [keyword, muscle] of Object.entries(keywords)) {
                    if (name.includes(keyword)) {
                        return { muscles: [muscle], primaryMuscle: muscle, matchType: 'keyword' };
                    }
                }
                
                return null;
            };
            
            // Trova esercizi simili con dati storici
            const findSimilarExerciseEstimate = (exerciseName) => {
                const muscleInfo = getExerciseMuscles(exerciseName);
                if (!muscleInfo) return null;
                
                const { primaryMuscle, muscles } = muscleInfo;
                let bestMatch = null;
                let bestScore = 0;
                
                // Cerca tra gli esercizi con dati storici
                for (const [estName, estimate] of Object.entries(exerciseEstimates)) {
                    const estMuscleInfo = getExerciseMuscles(estName);
                    if (!estMuscleInfo) continue;
                    
                    // Calcola score di similarit√†
                    let score = 0;
                    
                    // Match muscolo primario (peso alto)
                    if (estMuscleInfo.primaryMuscle === primaryMuscle) {
                        score += 10;
                    }
                    
                    // Match muscoli secondari
                    const commonMuscles = muscles.filter(m => estMuscleInfo.muscles.includes(m));
                    score += commonMuscles.length * 2;
                    
                    // Match stesso gruppo (push/pull/legs)
                    const getGroup = (muscle) => MUSCLE_GROUPS[muscle]?.group || 'other';
                    if (getGroup(primaryMuscle) === getGroup(estMuscleInfo.primaryMuscle)) {
                        score += 3;
                    }
                    
                    if (score > bestScore) {
                        bestScore = score;
                        bestMatch = {
                            name: estName,
                            estimate: estimate,
                            similarity: score,
                            primaryMuscle: estMuscleInfo.primaryMuscle
                        };
                    }
                }
                
                // Richiedi almeno un match sul muscolo primario
                return bestScore >= 10 ? bestMatch : null;
            };
            
            // Fattori di correzione per esercizi derivati
            const getExerciseCorrectionFactor = (newExercise, referenceExercise) => {
                const newName = normalizeExerciseName(newExercise);
                const refName = normalizeExerciseName(referenceExercise);
                
                // Esercizi con manubri tipicamente ~80% del bilanciere
                if ((newName.includes('manubr') || newName.includes('dumbbell')) && 
                    !refName.includes('manubr') && !refName.includes('dumbbell')) {
                    return 0.80;
                }
                
                // Varianti inclinate tipicamente ~85% della versione piana
                if (newName.includes('inclinat') && !refName.includes('inclinat')) {
                    return 0.85;
                }
                
                // Varianti unilaterali ~50% del bilaterale
                if ((newName.includes('singol') || newName.includes('single') || newName.includes('unilateral')) &&
                    !refName.includes('singol') && !refName.includes('single')) {
                    return 0.50;
                }
                
                // Default: stima conservativa al 85%
                return 0.85;
            };
            
            // Carica stime 1RM dai log storici
            const loadExerciseEstimates = () => {
                try {
                    const logs = JSON.parse(localStorage.getItem('ironflow_logs') || '[]');
                    exerciseEstimates = {};
                    
                    logs.forEach(log => {
                        if (!log.exercises) return;
                        log.exercises.forEach(ex => {
                            const name = normalizeExerciseName(ex.name);
                            if (!name || !ex.sets) return;
                            
                            ex.sets.forEach(set => {
                                const w = parseFloat(set.weight);
                                const r = parseInt(set.reps);
                                if (w > 0 && r > 0 && r <= 15) {
                                    const est1RM = calculateHybrid1RM(w, r);
                                    if (est1RM && (!exerciseEstimates[name] || est1RM > exerciseEstimates[name].est1RM)) {
                                        exerciseEstimates[name] = {
                                            est1RM: est1RM,
                                            basedOn: `${w}kg x ${r}`,
                                            date: log.date,
                                            originalName: ex.name
                                        };
                                    }
                                }
                            });
                        });
                    });
                    
                    console.log('üìä Stime caricate:', Object.keys(exerciseEstimates).length, 'esercizi');
                } catch (e) {
                    console.warn('Errore caricamento stime:', e);
                    exerciseEstimates = {};
                }
            };
            
            // EXPOSE GLOBALLY for sync scripts
            window.loadExerciseEstimates = loadExerciseEstimates;
            
            // Calcola peso suggerito per esercizio e reps target
            const getSuggestedWeight = (exerciseName, targetReps) => {
                // FIX: Ricarica stime se vuote (utile post-sync su iOS)
                if (!exerciseEstimates || Object.keys(exerciseEstimates).length === 0) {
                    loadExerciseEstimates();
                }

                const name = normalizeExerciseName(exerciseName);
                
                // Parsa le reps target (gestisce range come "8-12")
                let reps = parseInt(targetReps);
                if (isNaN(reps)) {
                    const match = String(targetReps || '').match(/(\d+)/);
                    reps = match ? parseInt(match[1]) : null;
                }
                
                if (!reps || reps < 1 || reps > 15) reps = 10; // Default a 10 reps se non specificato
                
                const percentage = rmPercentages[reps] || 0.70;
                
                // STEP 1: Cerca match ESATTO (nome normalizzato identico)
                const exactMatch = exerciseEstimates[name];
                if (exactMatch && exactMatch.est1RM) {
                    const suggestedWeight = Math.round(exactMatch.est1RM * percentage * 2) / 2;
                    return {
                        weight: suggestedWeight,
                        basedOn: exactMatch.basedOn, // es. "60kg x 8"
                        est1RM: Math.round(exactMatch.est1RM),
                        type: 'direct'
                    };
                }
                
                // STEP 2: Cerca match per parole chiave (pi√π robusto)
                const nameWords = name.split(' ').filter(w => w.length > 2);
                let bestMatch = null;
                let bestScore = 0;
                
                for (const [estName, estData] of Object.entries(exerciseEstimates)) {
                    const estWords = estName.split(' ').filter(w => w.length > 2);
                    
                    // Calcola quante parole in comune
                    const commonWords = nameWords.filter(w => estWords.includes(w));
                    const score = commonWords.length;
                    
                    // Match diretto se tutte le parole principali combaciano (almeno 2)
                    if (score >= Math.min(nameWords.length, estWords.length) && score >= 2) {
                        if (score > bestScore) {
                            bestScore = score;
                            bestMatch = { estName, estData, isDirect: true };
                        }
                    }
                    // Match simile se almeno 1 parola chiave combacia
                    else if (score >= 1 && !bestMatch) {
                        bestMatch = { estName, estData, isDirect: false };
                    }
                }
                
                if (bestMatch && bestMatch.isDirect) {
                    const suggestedWeight = Math.round(bestMatch.estData.est1RM * percentage * 2) / 2;
                    return {
                        weight: suggestedWeight,
                        basedOn: bestMatch.estData.basedOn,
                        est1RM: Math.round(bestMatch.estData.est1RM),
                        type: 'direct'
                    };
                }
                
                // STEP 3: Cerca esercizi simili per gruppo muscolare (fallback)
                const similarMatch = findSimilarExerciseEstimate(exerciseName);
                if (similarMatch) {
                    const correctionFactor = getExerciseCorrectionFactor(exerciseName, similarMatch.name);
                    const adjustedEst1RM = similarMatch.estimate.est1RM * correctionFactor;
                    const suggestedWeight = Math.round(adjustedEst1RM * percentage * 2) / 2;
                    
                    return {
                        weight: suggestedWeight,
                        basedOn: similarMatch.estimate.originalName || similarMatch.name,
                        est1RM: Math.round(adjustedEst1RM),
                        type: 'similar',
                        correctionFactor: correctionFactor
                    };
                }
                
                return null;
            };
            
            // Carica stime all'avvio
            loadExerciseEstimates();

            const DOMS_SELECTION_STORAGE_KEY = 'ironflow_last_doms_selection';
            const categoryOrder = ['push', 'pull', 'legs', 'core', 'other'];
            const groupLabels = {
                push: 'Spinta',
                pull: 'Trazione',
                legs: 'Lower Body',
                core: 'Core',
                other: 'Full Body'
            };

            const getCategoryRank = (key) => {
                const idx = categoryOrder.indexOf(key);
                return idx === -1 ? categoryOrder.length : idx;
            };

            const muscleOptions = Object.entries(MUSCLE_GROUPS).map(([id, meta]) => ({
                id,
                label: meta.label || id,
                category: meta.group || 'other'
            })).sort((a, b) => {
                const rankDiff = getCategoryRank(a.category) - getCategoryRank(b.category);
                if (rankDiff !== 0) return rankDiff;
                return a.label.localeCompare(b.label, 'it');
            });

            const muscleLabelMap = muscleOptions.reduce((acc, option) => {
                acc[option.id] = option.label;
                return acc;
            }, {});

            const loadStoredSelection = () => {
                try {
                    const raw = JSON.parse(localStorage.getItem(DOMS_SELECTION_STORAGE_KEY) || '[]');
                    return Array.isArray(raw) ? raw.filter(id => muscleLabelMap[id]) : [];
                } catch (error) {
                    console.warn('Impossibile leggere DOMS salvati:', error);
                    return [];
                }
            };

            let selectedSorenessMuscles = new Set(loadStoredSelection());

            const persistSorenessSelection = () => {
                localStorage.setItem(
                    DOMS_SELECTION_STORAGE_KEY,
                    JSON.stringify(Array.from(selectedSorenessMuscles))
                );
            };

            const updateSorenessHint = () => {
                if (!sorenessMuscleHint) return;
                if (!selectedSorenessMuscles.size) {
                    sorenessMuscleHint.textContent = 'Nessun distretto selezionato.';
                    return;
                }
                const labels = Array.from(selectedSorenessMuscles).map(id => muscleLabelMap[id] || id);
                sorenessMuscleHint.textContent = `Gruppi selezionati: ${labels.join(', ')}`;
            };

            const syncSorenessButtons = () => {
                if (!sorenessMusclePicker) return;
                sorenessMusclePicker.querySelectorAll('.doms-chip').forEach(btn => {
                    const id = btn.dataset.muscle;
                    const isActive = selectedSorenessMuscles.has(id);
                    btn.classList.toggle('active', isActive);
                    btn.setAttribute('aria-pressed', String(isActive));
                });
            };

            const buildSorenessPicker = () => {
                if (!sorenessMusclePicker) return;
                sorenessMusclePicker.innerHTML = '';
                const grouped = muscleOptions.reduce((acc, option) => {
                    const key = option.category || 'other';
                    if (!acc[key]) acc[key] = [];
                    acc[key].push(option);
                    return acc;
                }, {});

                Object.keys(grouped)
                    .sort((a, b) => getCategoryRank(a) - getCategoryRank(b))
                    .forEach(category => {
                        const header = document.createElement('div');
                        header.className = 'doms-chip-group';
                        header.textContent = groupLabels[category] || category;
                        sorenessMusclePicker.appendChild(header);

                        const wrapper = document.createElement('div');
                        wrapper.className = 'doms-chip-wrapper';

                        grouped[category].forEach(option => {
                            const btn = document.createElement('button');
                            btn.type = 'button';
                            btn.className = 'doms-chip' + (selectedSorenessMuscles.has(option.id) ? ' active' : '');
                            btn.dataset.muscle = option.id;
                            btn.textContent = option.label;
                            btn.setAttribute('role', 'option');
                            btn.setAttribute('aria-pressed', String(selectedSorenessMuscles.has(option.id)));
                            btn.addEventListener('click', () => {
                                if (selectedSorenessMuscles.has(option.id)) {
                                    selectedSorenessMuscles.delete(option.id);
                                } else {
                                    selectedSorenessMuscles.add(option.id);
                                }
                                btn.classList.toggle('active');
                                btn.setAttribute('aria-pressed', String(btn.classList.contains('active')));
                                persistSorenessSelection();
                                updateSorenessHint();
                            });
                            wrapper.appendChild(btn);
                        });

                        sorenessMusclePicker.appendChild(wrapper);
                    });
            };

            const hydrateSorenessSelection = () => {
                selectedSorenessMuscles = new Set(loadStoredSelection());
                syncSorenessButtons();
                updateSorenessHint();
            };

            buildSorenessPicker();
            updateSorenessHint();

            clearSorenessSelectionBtn?.addEventListener('click', (event) => {
                event.preventDefault();
                selectedSorenessMuscles.clear();
                persistSorenessSelection();
                syncSorenessButtons();
                updateSorenessHint();
            });

            // Share Modal Logic
            const shareModal = document.getElementById('shareModal');
            const closeShareModal = document.getElementById('closeShareModal');
            const shareWhatsapp = document.getElementById('shareWhatsapp');
            const shareTelegram = document.getElementById('shareTelegram');
            const shareTwitter = document.getElementById('shareTwitter');
            const shareFacebook = document.getElementById('shareFacebook');
            const shareEmail = document.getElementById('shareEmail');
            const shareCopy = document.getElementById('shareCopy');
            const shareNative = document.getElementById('shareNative');
            
            let currentShareUrl = '';
            let currentShareTitle = '';

            window.showShareModal = (title, url) => {
                const text = `Guarda la mia scheda "${title}" su GymBro!`;
                currentShareUrl = url;
                currentShareTitle = title;

                shareWhatsapp.href = `https://wa.me/?text=${encodeURIComponent(text + ' ' + url)}`;
                shareTelegram.href = `https://t.me/share/url?url=${encodeURIComponent(url)}&text=${encodeURIComponent(text)}`;
                shareTwitter.href = `https://twitter.com/intent/tweet?text=${encodeURIComponent(text)}&url=${encodeURIComponent(url)}`;
                shareFacebook.href = `https://www.facebook.com/sharer/sharer.php?u=${encodeURIComponent(url)}`;
                shareEmail.href = `mailto:?subject=${encodeURIComponent('Scheda Allenamento GymBro')}&body=${encodeURIComponent(text + '\n\n' + url)}`;

                shareCopy.onclick = async () => {
                    await navigator.clipboard.writeText(url);
                    shareCopy.innerHTML = '<span style="font-size: 2rem;">‚úÖ</span><span>Copiato!</span>';
                    setTimeout(() => {
                        shareCopy.innerHTML = '<span style="font-size: 2rem;">üìã</span><span>Copia Link</span>';
                    }, 2000);
                };

                shareModal.style.display = 'flex';
            };
            
            // Native share button handler
            shareNative.addEventListener('click', async () => {
                if (navigator.share && currentShareUrl) {
                    try {
                        await navigator.share({
                            title: `Allenamento: ${currentShareTitle}`,
                            text: `Guarda la mia scheda "${currentShareTitle}" su GymBro!`,
                            url: currentShareUrl
                        });
                        shareModal.style.display = 'none';
                    } catch (err) {
                        if (err.name !== 'AbortError') {
                            console.error('Share failed:', err);
                        }
                    }
                } else {
                    // Fallback: copy to clipboard
                    await navigator.clipboard.writeText(currentShareUrl);
                    shareNative.innerHTML = '<span style="font-size: 2rem;">‚úÖ</span><span>Copiato!</span>';
                    setTimeout(() => {
                        shareNative.innerHTML = '<span style="font-size: 2rem;">üì§</span><span>Condividi</span>';
                    }, 2000);
                }
            });

            closeShareModal.addEventListener('click', () => {
                shareModal.style.display = 'none';
            });

            shareModal.addEventListener('click', (e) => {
                if (e.target === shareModal) shareModal.style.display = 'none';
            });

            // Global Helpers for HTML attributes
            window.adjustTimer = (seconds) => {
                if (timerWorker) {
                    timerWorker.postMessage({ action: 'adjust', seconds: seconds });
                } else {
                    // Fallback (visual update primarily, logic in interval)
                    // This is complex to sync without worker, but we try our best if worker fails
                    // Ideally worker is always present in modern browsers
                    alert("Funzione non disponibile senza supporto Web Worker.");
                }
            };

            window.skipRest = () => {
                stopTimer();
                isResting = false;
                nextSet();
            };

            const generateWorkoutId = () => {
                if (window.crypto?.randomUUID) {
                    return 'wf_' + crypto.randomUUID();
                }
                return 'wf_' + Date.now().toString(36) + Math.random().toString(36).slice(2, 8);
            };

            function getStoredWorkouts() {
                try {
                    const raw = JSON.parse(localStorage.getItem('ironflow_workouts') || '[]');
                    return Array.isArray(raw) ? raw : [];
                } catch (error) {
                    console.error('Errore lettura schede', error);
                    return [];
                }
            }

            const findWorkoutById = (id) => {
                if (!id) return null;
                return getStoredWorkouts().find(w => String(w.id) === String(id));
            };

            const parseTargetInfo = (value) => {
                if (value === undefined || value === null) return { label: '', numeric: '' };
                if (typeof value === 'number' && !Number.isNaN(value)) {
                    return { label: `${value}`, numeric: value };
                }
                if (typeof value === 'string') {
                    const trimmed = value.trim();
                    if (!trimmed) return { label: '', numeric: '' };
                    const numeric = parseFloat(trimmed.replace(',', '.'));
                    return {
                        label: trimmed,
                        numeric: Number.isNaN(numeric) ? '' : numeric
                    };
                }
                return { label: '', numeric: '' };
            };

            const buildSetsFromPlan = (exercise) => {
                const rawCount = exercise.sets ?? exercise.series ?? exercise.setCount ?? exercise.seriesCount;
                const parsed = parseInt(rawCount, 10);
                const setCount = Number.isFinite(parsed) && parsed > 0 ? parsed : 1;
                const target = parseTargetInfo(exercise.reps);
                const baseWeight = Number(exercise.weight || exercise.defaultWeight || 0) || 0;

                return Array.from({ length: setCount }, () => ({
                    weight: baseWeight,
                    reps: target.numeric,
                    target: target.label
                }));
            };

            function cloneWorkout(workout) {
                if (!workout) return null;
                const clone = JSON.parse(JSON.stringify(workout));
                if (!Array.isArray(clone.exercises)) clone.exercises = [];
                clone.exercises = clone.exercises.map(ex => {
                    const safeSets = Array.isArray(ex.sets) && ex.sets.length
                        ? ex.sets.map(set => {
                            const targetInfo = parseTargetInfo(set.target || set.reps || ex.reps);
                            return {
                                weight: Number(set.weight ?? ex.weight ?? 0) || 0,
                                reps: set.reps !== undefined && set.reps !== null && set.reps !== '' ? set.reps : targetInfo.numeric,
                                target: set.target || targetInfo.label
                            };
                        })
                        : buildSetsFromPlan(ex);
                    return {
                        ...ex,
                        name: ex.name || 'Esercizio',
                        sets: safeSets
                    };
                });
                return clone;
            }

            function hydrateFocusWorkout(workout, { showNotice = false, skipClone = false } = {}) {
                const readyWorkout = skipClone ? workout : cloneWorkout(workout);
                if (!readyWorkout || !Array.isArray(readyWorkout.exercises) || readyWorkout.exercises.length === 0) {
                    return null;
                }
                currentWorkout = readyWorkout;
                currentExerciseIndex = 0;
                currentSetIndex = 0;
                sessionCompleted = false;
                isResting = false;
                focusHistoryList.innerHTML = '';
                if (showNotice) {
                    const notice = document.createElement('div');
                    notice.style.color = 'var(--color-primary)';
                    notice.style.fontSize = '0.8rem';
                    notice.textContent = 'Scheda aggiornata. Sessione riallineata.';
                    focusHistoryList.appendChild(notice);
                }
                focusWorkoutTitle.textContent = readyWorkout.name || 'Workout Personalizzato';
                updateFocusUI();
                return readyWorkout;
            }

            function syncFocusOverlayWithLatestPlan() {
                if (focusOverlay.style.display !== 'flex' || !currentWorkoutId) return;
                const updated = findWorkoutById(currentWorkoutId);
                if (!updated) {
                    finishWorkout(true);
                    return;
                }
                const refreshed = hydrateFocusWorkout(updated, { showNotice: true });
                if (!refreshed) {
                    finishWorkout(true);
                }
            }

            function openWellnessModal(workout) {
                pendingFocusWorkout = workout;
                currentWellnessSnapshot = null;
                wellnessModal.style.display = 'flex';
                sleepQualityInput.value = sleepQualityInput.value || 7;
                energyLevelInput.value = energyLevelInput.value || 7;
                stressLevelInput.value = stressLevelInput.value || 4;
                sorenessLevelInput.value = sorenessLevelInput.value || 3;
                hydrateSorenessSelection();
            }

            function closeWellnessModal() {
                wellnessModal.style.display = 'none';
                pendingFocusWorkout = null;
            }

            function startFocusSession(workout) {
                // Ricarica stime 1RM prima di iniziare (per avere dati aggiornati)
                loadExerciseEstimates();
                
                const source = typeof workout === 'string'
                    ? findWorkoutById(workout)
                    : (workout?.id ? (findWorkoutById(workout.id) || workout) : workout);

                const hydrated = hydrateFocusWorkout(source || null);

                if (!hydrated) {
                    alert('Questa scheda non contiene esercizi validi. Aggiornala dal Creator prima di avviare la modalit√† Focus.');
                    return;
                }

                currentWorkoutId = hydrated.id || source?.id || null;
                sessionStartTime = Date.now();
                sessionLogSaved = false;
                
                // Expose variables globally for session recovery
                window.currentFocusWorkout = currentWorkout;
                window.focusModeStartTime = sessionStartTime;
                window.focusModeWellnessData = currentWellnessSnapshot;
                window.focusModeSessionCompleted = false;
                
                // Blocca scroll del body quando Focus Mode √® aperta
                document.body.style.overflow = 'hidden';
                document.body.style.position = 'fixed';
                document.body.style.width = '100%';
                document.body.style.top = `-${window.scrollY}px`;
                
                focusOverlay.style.display = 'flex';
            }

            window.initFocusMode = (workout) => {
                notificationManager.requestPermission();
                // Start silent audio loop to keep audio active in background (critical for iOS)
                notificationManager.startSilentLoop();
                openWellnessModal(workout);
            };

            cancelWellnessBtn.addEventListener('click', () => {
                wellnessModal.style.display = 'none';
                pendingFocusWorkout = null;
            });

            wellnessForm.addEventListener('submit', (e) => {
                e.preventDefault();
                const recordedAt = new Date().toISOString();
                const muscleSelection = Array.from(selectedSorenessMuscles);
                const externalCauseInput = document.getElementById('domsExternalCauseInput');
                const externalCause = externalCauseInput ? externalCauseInput.value.trim() : '';
                
                currentWellnessSnapshot = {
                    sleepQuality: parseInt(sleepQualityInput.value, 10),
                    energyLevel: parseInt(energyLevelInput.value, 10),
                    stressLevel: parseInt(stressLevelInput.value, 10),
                    sorenessLevel: parseInt(sorenessLevelInput.value, 10),
                    recordedAt,
                    sorenessMuscles: muscleSelection,
                    sorenessLabels: muscleSelection.map(id => muscleLabelMap[id] || id),
                    externalCause: externalCause || undefined // Only include if provided
                };
                
                // Clear external cause input for next session
                if (externalCauseInput) externalCauseInput.value = '';
                
                console.log('[Wellness] Snapshot created:', currentWellnessSnapshot);
                console.log('[Wellness] Selected DOMS muscles:', muscleSelection);
                if (externalCause) console.log('[Wellness] External cause:', externalCause);
                wellnessModal.style.display = 'none';
                if (pendingFocusWorkout) {
                    startFocusSession(pendingFocusWorkout);
                    pendingFocusWorkout = null;
                }
            });

            exitFocusModeBtn.addEventListener('click', () => {
                // Check if there's progress to save
                const hasProgress = currentExerciseIndex > 0 || currentSetIndex > 0;
                
                if (hasProgress) {
                    // Offer to save progress
                    const choice = confirm('Vuoi salvare i progressi per continuare dopo?\n\nOK = Salva e esci\nAnnulla = Esci senza salvare');
                    
                    if (choice) {
                        // User wants to save - session will be saved by recovery manager
                        console.log('üíæ Saving session before exit...');
                        // Don't mark as completed so recovery manager keeps the session
                        window.focusModeSessionCompleted = false;
                    } else {
                        // User doesn't want to save - mark as completed to clear session
                        window.focusModeSessionCompleted = true;
                    }
                } else {
                    // No progress, just exit
                    window.focusModeSessionCompleted = true;
                }
                
                stopTimer();
                // Ripristina scroll del body
                const scrollY = document.body.style.top;
                document.body.style.overflow = '';
                document.body.style.position = '';
                document.body.style.width = '';
                document.body.style.top = '';
                window.scrollTo(0, parseInt(scrollY || '0') * -1);
                focusOverlay.style.display = 'none';
            });

            let supersetModeActive = false;

            function renderNormalInputs() {
                if (!supersetModeActive) return; // Already normal
                supersetModeActive = false;
                
                focusActiveArea.innerHTML = `
                <div id="focusBilateralIndicator" style="display: none; background: linear-gradient(135deg, rgba(156,39,176,0.15), rgba(103,58,183,0.1)); border: 1px solid rgba(156,39,176,0.3); border-radius: var(--radius-md); padding: 0.5rem 1rem; margin-bottom: 0.75rem; text-align: center;">
                    <div style="display: flex; align-items: center; justify-content: center; gap: 0.5rem;">
                        <span style="font-size: 1rem;">üèãÔ∏è</span>
                        <span style="color: #ce93d8; font-size: 0.8rem; font-weight: 500;">Manubri Bilaterali</span>
                        <span style="color: var(--color-text-muted); font-size: 0.7rem;">‚Ä¢ Inserisci peso singolo manubrio</span>
                    </div>
                </div>
                <div id="focusSuggestedWeight" style="display: none; background: linear-gradient(135deg, rgba(0,243,255,0.15), rgba(0,153,255,0.1)); border: 1px solid rgba(0,243,255,0.3); border-radius: var(--radius-md); padding: 0.6rem 1rem; margin-bottom: 1rem; text-align: center;">
                    <div style="display: flex; align-items: center; justify-content: center; gap: 0.5rem; flex-wrap: wrap;">
                        <span style="color: var(--color-text-muted); font-size: 0.75rem;">üí° Suggerito:</span>
                        <span id="focusSuggestedValue" style="color: var(--color-primary); font-weight: bold; font-size: 1.1rem;">--</span>
                        <span style="color: var(--color-text-muted); font-size: 0.7rem;" id="focusSuggestedBasis">(basato su storico)</span>
                    </div>
                </div>
                <div style="display: grid; grid-template-columns: 1fr 1fr 1fr; gap: 0.75rem; margin-bottom: 1.5rem;">
                    <div style="background: var(--color-surface); padding: 0.75rem 0.5rem; border-radius: var(--radius-md); border: 1px solid var(--color-border); text-align: center;">
                        <label id="focusWeightLabel" style="display: block; color: var(--color-text-muted); font-size: 0.7rem; margin-bottom: 0.3rem;">KG</label>
                        <input type="number" id="focusWeightInput" style="width: 100%; background: transparent; border: none; color: white; font-size: 2rem; text-align: center; font-weight: bold; font-family: var(--font-display);" value="">
                    </div>
                    <div style="background: var(--color-surface); padding: 0.75rem 0.5rem; border-radius: var(--radius-md); border: 1px solid var(--color-border); text-align: center;">
                        <label style="display: block; color: var(--color-text-muted); font-size: 0.7rem; margin-bottom: 0.3rem;">REPS</label>
                        <input type="text" id="focusRepsInput" style="width: 100%; background: transparent; border: none; color: white; font-size: 2rem; text-align: center; font-weight: bold; font-family: var(--font-display);" value="">
                    </div>
                    <div style="background: var(--color-surface); padding: 0.75rem 0.5rem; border-radius: var(--radius-md); border: 1px solid var(--color-border); text-align: center;">
                        <label style="display: block; color: var(--color-text-muted); font-size: 0.7rem; margin-bottom: 0.3rem;">RPE</label>
                        <input type="number" id="focusRpeInput" min="1" max="10" step="0.5" style="width: 100%; background: transparent; border: none; color: white; font-size: 2rem; text-align: center; font-weight: bold; font-family: var(--font-display);" value="" placeholder="1-10">
                    </div>
                </div>
                `;
            }

            function renderSupersetInputs(exA, exB, setA, setB) {
                supersetModeActive = true;
                
                const targetA = setA?.target || exA.reps || '';
                const targetB = setB?.target || exB.reps || '';
                
                // Get suggestions for both
                const suggestA = getSuggestedWeight(exA.name, targetA);
                const suggestB = getSuggestedWeight(exB.name, targetB);

                const htmlA = `
                    <div class="superset-block-a" style="margin-bottom: 1rem; padding-bottom: 1rem; border-bottom: 1px dashed rgba(255,255,255,0.1);">
                        <div style="font-size: 1rem; color: var(--color-primary); margin-bottom: 0.5rem;">A: ${exA.name}</div>
                        ${suggestA ? `<div style="font-size: 0.75rem; color: #aaa; margin-bottom: 0.5rem;">üí° Suggerito: <span style="color:var(--color-primary)">${suggestA.weight}kg</span></div>` : ''}
                        <div style="display: grid; grid-template-columns: 1fr 1fr 1fr; gap: 0.5rem;">
                            <div style="background: rgba(255,255,255,0.03); padding: 0.5rem; border-radius: 6px;">
                                <label style="font-size: 0.6rem; color: #888;">KG</label>
                                <input type="number" id="focusWeightInput_A" value="${setA.weight || ''}" placeholder="${setA.weight || 'Kg'}" style="width:100%; background:transparent; border:none; color:white; font-size:1.2rem; text-align:center;">
                            </div>
                            <div style="background: rgba(255,255,255,0.03); padding: 0.5rem; border-radius: 6px;">
                                <label style="font-size: 0.6rem; color: #888;">REPS</label>
                                <input type="text" id="focusRepsInput_A" value="${setA.reps || ''}" placeholder="${targetA || 'Reps'}" style="width:100%; background:transparent; border:none; color:white; font-size:1.2rem; text-align:center;">
                            </div>
                            <div style="background: rgba(255,255,255,0.03); padding: 0.5rem; border-radius: 6px;">
                                <label style="font-size: 0.6rem; color: #888;">RPE</label>
                                <input type="number" id="focusRpeInput_A" value="${setA.rpe || ''}" placeholder="1-10" style="width:100%; background:transparent; border:none; color:white; font-size:1.2rem; text-align:center;">
                            </div>
                        </div>
                    </div>
                `;

                const htmlB = `
                    <div class="superset-block-b">
                        <div style="font-size: 1rem; color: #ff6b6b; margin-bottom: 0.5rem;">B: ${exB.name}</div>
                        ${suggestB ? `<div style="font-size: 0.75rem; color: #aaa; margin-bottom: 0.5rem;">üí° Suggerito: <span style="color:#ff6b6b">${suggestB.weight}kg</span></div>` : ''}
                        <div style="display: grid; grid-template-columns: 1fr 1fr 1fr; gap: 0.5rem;">
                            <div style="background: rgba(255,255,255,0.03); padding: 0.5rem; border-radius: 6px;">
                                <label style="font-size: 0.6rem; color: #888;">KG</label>
                                <input type="number" id="focusWeightInput_B" value="${setB.weight || ''}" placeholder="${setB.weight || 'Kg'}" style="width:100%; background:transparent; border:none; color:white; font-size:1.2rem; text-align:center;">
                            </div>
                            <div style="background: rgba(255,255,255,0.03); padding: 0.5rem; border-radius: 6px;">
                                <label style="font-size: 0.6rem; color: #888;">REPS</label>
                                <input type="text" id="focusRepsInput_B" value="${setB.reps || ''}" placeholder="${targetB || 'Reps'}" style="width:100%; background:transparent; border:none; color:white; font-size:1.2rem; text-align:center;">
                            </div>
                            <div style="background: rgba(255,255,255,0.03); padding: 0.5rem; border-radius: 6px;">
                                <label style="font-size: 0.6rem; color: #888;">RPE</label>
                                <input type="number" id="focusRpeInput_B" value="${setB.rpe || ''}" placeholder="1-10" style="width:100%; background:transparent; border:none; color:white; font-size:1.2rem; text-align:center;">
                            </div>
                        </div>
                    </div>
                `;

                focusActiveArea.innerHTML = `
                    <div class="superset-container" style="background: rgba(0,0,0,0.3); border: 1px solid rgba(255,107,107,0.3); border-radius: 12px; padding: 1rem;">
                        <div style="text-align:center; margin-bottom:1rem; color:#ff6b6b; font-size:0.8rem; font-weight:bold; letter-spacing:1px;">üîó SUPERSET COMBINATO</div>
                        ${htmlA}
                        ${htmlB}
                    </div>
                `;
            }

            focusActionBtn.addEventListener('click', () => {
                if (sessionCompleted) {
                    // Session completed normally - clear recovery data
                    window.focusModeSessionCompleted = true;
                    stopTimer();
                    // Ripristina scroll del body
                    const scrollY = document.body.style.top;
                    document.body.style.overflow = '';
                    document.body.style.position = '';
                    document.body.style.width = '';
                    document.body.style.top = '';
                    window.scrollTo(0, parseInt(scrollY || '0') * -1);
                    focusOverlay.style.display = 'none';
                    return;
                }

                if (isResting) {
                    window.skipRest();
                } else {
                    if (supersetModeActive) {
                        // === SUPERSET COMBINED LOGGING ===
                        const exA = currentWorkout.exercises[currentExerciseIndex];
                        const exB = currentWorkout.exercises[currentExerciseIndex + 1];
                        const setA = exA.sets[currentSetIndex];
                        const setB = exB.sets[currentSetIndex];

                        const wInputA = document.getElementById('focusWeightInput_A');
                        const rInputA = document.getElementById('focusRepsInput_A');
                        const rpeInputA = document.getElementById('focusRpeInput_A');
                        const wInputB = document.getElementById('focusWeightInput_B');
                        const rInputB = document.getElementById('focusRepsInput_B');
                        const rpeInputB = document.getElementById('focusRpeInput_B');

                        const valWA = parseFloat(wInputA?.value) || 0;
                        const valRA = rInputA?.value || setA?.target || setA?.reps || '';
                        const valRpeA = parseFloat(rpeInputA?.value) || 0;

                        const valWB = parseFloat(wInputB?.value) || 0;
                        const valRB = rInputB?.value || setB?.target || setB?.reps || '';
                        const valRpeB = parseFloat(rpeInputB?.value) || 0;

                        if (setA) {
                            setA.weight = valWA;
                            setA.reps = valRA;
                            if (valRpeA) setA.rpe = valRpeA;
                        }
                        if (setB) {
                            setB.weight = valWB;
                            setB.reps = valRB;
                            if (valRpeB) setB.rpe = valRpeB;
                        }

                        const historyItem = document.createElement('div');
                        historyItem.innerHTML = `
                            <div style="display:flex; flex-direction:column; gap:4px; border-left: 3px solid #ff6b6b; padding-left: 8px; margin-bottom: 6px; background: rgba(255,107,107,0.05); padding: 6px; border-radius: 0 6px 6px 0;">
                                <div style="font-size:0.85rem;">‚úÖ <strong style="color:var(--color-primary)">A:</strong> ${valWA}kg x ${valRA}</div>
                                <div style="font-size:0.85rem;">‚úÖ <strong style="color:#ff6b6b">B:</strong> ${valWB}kg x ${valRB}</div>
                            </div>
                        `;
                        focusHistoryList.prepend(historyItem);
                        startRest();

                    } else {
                        // === NORMAL LOGGING ===
                        const weightInput = document.getElementById('focusWeightInput');
                        const repsInput = document.getElementById('focusRepsInput');
                        const rpeInput = document.getElementById('focusRpeInput');
                        
                        const activeExercise = currentWorkout?.exercises?.[currentExerciseIndex];
                        const activeSet = activeExercise?.sets?.[currentSetIndex];

                        const weightInputRaw = weightInput.value.trim();
                        const repsInputRaw = repsInput.value.trim();
                        const rpeInputRaw = rpeInput.value.trim();

                        let loggedWeight = weightInputRaw === '' ? 0 : parseFloat(weightInputRaw) || 0;
                        const loggedReps = repsInputRaw || activeSet?.target || activeSet?.reps || '';
                        const loggedRpe = rpeInputRaw ? parseFloat(rpeInputRaw) : 0;
                        
                        const isBilateral = isBilateralDumbbell(activeExercise?.name);
                        const totalWeight = isBilateral ? calculateTotalWeight(activeExercise?.name, loggedWeight) : loggedWeight;

                        if (activeSet) {
                            activeSet.weight = totalWeight;
                            activeSet.isBilateral = isBilateral;
                            if (repsInputRaw) activeSet.reps = repsInputRaw;
                            if (loggedRpe > 0) activeSet.rpe = loggedRpe;
                        }

                        const historyItem = document.createElement('div');
                        const repsDisplay = loggedReps || '‚Äî';
                        const weightDisplay = totalWeight ? (isBilateral ? `${totalWeight}kg (${loggedWeight}x2)` : `${totalWeight}kg`) : '‚Äî';
                        const rpeDisplay = loggedRpe > 0 ? ` @ RPE ${loggedRpe}` : '';
                        
                        const setTypeBadges = {
                            normal: '',
                            warmup: '<span style="color:#ffc107;font-size:0.8em;">[W]</span> ',
                            backoff: '<span style="color:#9c27b0;font-size:0.8em;">[B]</span> ',
                            dropset: '<span style="color:#f44336;font-size:0.8em;">[D]</span> ',
                            amrap: '<span style="color:#4caf50;font-size:0.8em;">[A]</span> ',
                            pause: '<span style="color:#ff9800;font-size:0.8em;">[P]</span> '
                        };
                        const setType = activeSet?.type || 'normal';
                        const typeBadge = setTypeBadges[setType] || '';
                        
                        historyItem.innerHTML = `‚úÖ ${typeBadge}Set ${currentSetIndex + 1}: ${weightDisplay} x ${repsDisplay}${rpeDisplay}`;
                        focusHistoryList.prepend(historyItem);

                        startRest();
                    }
                }
            });

            function updateFocusUI() {
                if (!currentWorkout || !Array.isArray(currentWorkout.exercises) || currentWorkout.exercises.length === 0) {
                    finishWorkout(true);
                    return;
                }

                if (currentExerciseIndex >= currentWorkout.exercises.length) {
                    finishWorkout();
                    return;
                }

                const ex = currentWorkout.exercises[currentExerciseIndex];

                // Ensure sets exists
                if (!ex.sets || ex.sets.length === 0) {
                    // Skip exercise if empty
                    currentExerciseIndex++;
                    updateFocusUI();
                    return;
                }

                const set = ex.sets[currentSetIndex];
                
                // CHECK FOR SUPERSET COMBINED MODE
                // If this is Role A, and next is Role B of same Superset
                if (ex.supersetId && ex.supersetRole === 'A') {
                    const nextEx = currentWorkout.exercises[currentExerciseIndex + 1];
                    if (nextEx && nextEx.supersetId === ex.supersetId && nextEx.supersetRole === 'B') {
                        // Render Combined UI
                        const nextSet = nextEx.sets[currentSetIndex];
                        if (set && nextSet) {
                            focusExerciseName.textContent = `${ex.name} + ${nextEx.name}`;
                            focusExerciseName.style.fontSize = '1.1rem';
                            
                            renderSupersetInputs(ex, nextEx, set, nextSet);
                            updateFocusCommon(ex, set);
                            return;
                        }
                    }
                }

                // Normal Mode
                focusExerciseName.textContent = ex.name;
                focusExerciseName.style.fontSize = '';
                
                renderNormalInputs();
                updateFocusCommon(ex, set);
            }
            
            function updateFocusCommon(ex, set) {
                const targetLabel = set?.target || ex.reps || '';
                const baseCounter = `Set ${currentSetIndex + 1} / ${ex.sets.length}`;
                
                // Set Type Badge
                const setTypeLabels = {
                    normal: '',
                    warmup: 'üî• Warm-up',
                    backoff: 'üìâ Back-off',
                    dropset: '‚¨áÔ∏è Drop Set',
                    amrap: 'üí™ AMRAP',
                    pause: '‚è∏Ô∏è Pausa'
                };
                const setType = set?.type || 'normal';
                const setTypeLabel = setTypeLabels[setType] || '';
                
                let counterText = baseCounter;
                if (setTypeLabel) {
                    counterText = `${setTypeLabel} ‚Ä¢ ${baseCounter}`;
                }
                
                focusSetCounter.textContent = counterText;

                // Check if bilateral dumbbell exercise (Only relevant for Normal Mode indicator usually)
                const isBilateral = isBilateralDumbbell(ex.name);
                const bilateralIndicator = document.getElementById('focusBilateralIndicator');
                const weightLabel = document.getElementById('focusWeightLabel');
                
                if (bilateralIndicator) {
                    bilateralIndicator.style.display = isBilateral ? 'block' : 'none';
                }
                if (weightLabel) {
                    weightLabel.textContent = isBilateral ? 'KG (x1)' : 'KG';
                }
                
                // Populate Inputs for Normal Mode (Superset mode handles its own values in renderSupersetInputs)
                const weightInput = document.getElementById('focusWeightInput');
                const repsInput = document.getElementById('focusRepsInput');
                const rpeInput = document.getElementById('focusRpeInput');
                
                if (weightInput) {
                    weightInput.value = set.weight || '';
                    weightInput.placeholder = set.weight || 'Kg';
                }
                if (repsInput) {
                    repsInput.value = set.reps || '';
                    repsInput.placeholder = targetLabel || 'Reps';
                    
                    // Update suggestion when reps change
                    repsInput.oninput = () => {
                        const val = repsInput.value;
                        if (val) {
                            const suggestion = getSuggestedWeight(ex.name, val);
                            const focusSuggestedWeight = document.getElementById('focusSuggestedWeight');
                            const focusSuggestedValue = document.getElementById('focusSuggestedValue');
                            const focusSuggestedBasis = document.getElementById('focusSuggestedBasis');
                            
                            if (suggestion && focusSuggestedWeight) {
                                focusSuggestedValue.textContent = `${suggestion.weight} kg`;
                                if (suggestion.type === 'direct') {
                                    focusSuggestedBasis.textContent = `(1RM da ${suggestion.basedOn})`;
                                } else {
                                    focusSuggestedBasis.textContent = `(stimato da ${suggestion.basedOn})`;
                                }
                                focusSuggestedWeight.style.display = 'block';
                            }
                        }
                    };
                }
                if (rpeInput) {
                    rpeInput.value = set.rpe || '';
                }

                // Suggestions Logic
                const focusSuggestedWeight = document.getElementById('focusSuggestedWeight');
                const focusSuggestedValue = document.getElementById('focusSuggestedValue');
                const focusSuggestedBasis = document.getElementById('focusSuggestedBasis');
                
                if (focusSuggestedWeight && !supersetModeActive) {
                    const targetReps = set.target || ex.reps || '10';
                    let suggestion = null;
                    
                    if (set.suggestedWeight) {
                        suggestion = {
                            weight: set.suggestedWeight,
                            basedOn: set.suggestedBasedOn || 'storico',
                            type: set.suggestedType || 'ai-generated'
                        };
                    } else {
                        // Calcola al volo dai dati storici
                        suggestion = getSuggestedWeight(ex.name, targetReps);
                    }
                    
                    if (suggestion) {
                        focusSuggestedValue.textContent = `${suggestion.weight} kg`;
                        
                        if (suggestion.type === 'direct') {
                            focusSuggestedBasis.textContent = `(1RM da ${suggestion.basedOn})`;
                            focusSuggestedWeight.style.background = 'linear-gradient(135deg, rgba(0,243,255,0.15), rgba(0,153,255,0.1))';
                            focusSuggestedWeight.style.borderColor = 'rgba(0,243,255,0.3)';
                        } else if (suggestion.type === 'similar' || suggestion.type === 'ai-generated') {
                            const basisText = suggestion.type === 'ai-generated' ? 'calcolato da AI' : `stimato da ${suggestion.basedOn}`;
                            focusSuggestedBasis.textContent = `(${basisText})`;
                            focusSuggestedWeight.style.background = 'linear-gradient(135deg, rgba(255,193,7,0.15), rgba(255,152,0,0.1))';
                            focusSuggestedWeight.style.borderColor = 'rgba(255,193,7,0.3)';
                        }
                        
                        focusSuggestedWeight.style.display = 'block';
                    } else {
                        focusSuggestedWeight.style.display = 'none';
                    }
                }

                // Reset UI State
                focusActiveArea.style.display = 'block';
                focusTimerArea.style.display = 'none';
                focusActionBtn.textContent = "FATTO";
                focusActionBtn.className = 'btn btn-primary';
                focusActionBtn.style.background = 'var(--color-primary)';
                focusActionBtn.style.color = 'black';

                // Update Progress Bar
                const totalSets = currentWorkout.exercises.reduce((acc, e) => acc + (e.sets ? e.sets.length : 0), 0);
                // Calc completed
                let completed = 0;
                for (let i = 0; i < currentExerciseIndex; i++) completed += currentWorkout.exercises[i].sets.length;
                completed += currentSetIndex;

                const percent = Math.round((completed / totalSets) * 100);
                focusProgressBar.style.width = percent + '%';
                focusProgressText.textContent = percent + '%';
                
                // Update Next Exercise Preview
                const nextExercisePreview = document.getElementById('nextExercisePreview');
                const nextExerciseName = document.getElementById('nextExerciseName');
                const nextExerciseSets = document.getElementById('nextExerciseSets');
                
                if (nextExercisePreview && nextExerciseName && nextExerciseSets) {
                    let nextExIndex = currentExerciseIndex + 1;
                    if (supersetModeActive) nextExIndex++; // Skip the partner in preview

                    if (nextExIndex < currentWorkout.exercises.length) {
                        const nextEx = currentWorkout.exercises[nextExIndex];
                        nextExerciseName.textContent = nextEx.name || 'Esercizio';
                        const setsCount = nextEx.sets ? nextEx.sets.length : 0;
                        nextExerciseSets.textContent = `${setsCount} serie`;
                        nextExercisePreview.style.display = 'block';
                    } else {
                        // No more exercises after current
                        nextExercisePreview.style.display = 'none';
                    }
                }
            }

            let timerWorker = null;

            if (window.Worker) {
                timerWorker = new Worker('js/timer.worker.js');
                timerWorker.onmessage = function (e) {
                    if (e.data.action === 'tick') {
                        updateTimerDisplay(e.data.remaining);
                    } else if (e.data.action === 'complete') {
                        updateTimerDisplay(0);
                        notificationManager.triggerNotification();
                        window.skipRest();
                    }
                };
            }

            function startRest() {
                notificationManager.unlockAudio();
                isResting = true;

                // Hide inputs, show timer
                focusActiveArea.style.display = 'none';
                focusTimerArea.style.display = 'block';

                const currentEx = currentWorkout.exercises[currentExerciseIndex];
                const exName = currentEx.name.toLowerCase();
                
                // Check for superset logic
                let restTime = 90; // Default
                let restLabel = 'RECUPERO';
                
                if (currentEx.supersetId) {
                    if (supersetModeActive) {
                        // Combined Superset Mode (A+B just finished)
                        // Use inter-superset rest (usually defined on A)
                        restTime = currentEx.interRest || 90;
                        restLabel = 'RECUPERO SUPERSET';
                    } else {
                        // Sequential Mode
                        const nextExIndex = currentExerciseIndex + 1;
                        const nextEx = currentWorkout.exercises[nextExIndex];
                        
                        if (currentEx.supersetRole === 'A' && nextEx?.supersetId === currentEx.supersetId) {
                            // Transitioning from A to B within superset
                            restTime = currentEx.intraRest || 0;
                            restLabel = 'TRANSIZIONE A‚ÜíB';
                            
                            if (restTime === 0) {
                                // No rest, go directly to exercise B
                                isResting = false;
                                currentExerciseIndex++;
                                // Keep same set index for paired tracking
                                updateFocusUI();
                                return;
                            }
                        } else if (currentEx.supersetRole === 'B') {
                            // After completing B, check if we need inter-superset rest
                            const prevEx = currentWorkout.exercises[currentExerciseIndex - 1];
                            if (prevEx?.supersetId === currentEx.supersetId && prevEx?.supersetRole === 'A') {
                                // Use inter-superset rest from exercise A
                                restTime = prevEx.interRest || 90;
                                restLabel = 'RECUPERO SUPERSET';
                            }
                        }
                    }
                } else {
                    // Standard rest logic for non-superset exercises
                    if (currentEx.rest) {
                        restTime = currentEx.rest;
                    } else if (exName.includes('squat') || exName.includes('stacco') || exName.includes('deadlift') || exName.includes('panca') || exName.includes('bench')) {
                        restTime = 180; // Compounds
                    } else if (exName.includes('curl') || exName.includes('alzate') || exName.includes('polpacci') || exName.includes('abs')) {
                        restTime = 60; // Isolation
                    }
                }

                // Update timer label
                const timerLabel = focusTimerArea.querySelector('div');
                if (timerLabel) timerLabel.textContent = restLabel;
                
                updateTimerDisplay(restTime);

                focusActionBtn.textContent = "SALTA REST";
                focusActionBtn.style.background = 'transparent';
                focusActionBtn.style.border = '1px solid #333';
                focusActionBtn.style.color = 'white';

                // Start Worker Timer
                if (timerWorker) {
                    timerWorker.postMessage({ action: 'start', duration: restTime });
                } else {
                    // Fallback if Workers not supported
                    const endTime = Date.now() + restTime * 1000;
                    if (timerInterval) clearInterval(timerInterval);
                    timerInterval = setInterval(() => {
                        const remaining = Math.ceil((endTime - Date.now()) / 1000);
                        if (remaining <= 0) {
                            clearInterval(timerInterval);
                            notificationManager.triggerNotification();
                            window.skipRest();
                        } else {
                            updateTimerDisplay(remaining);
                        }
                    }, 250);
                }
            }

            function updateTimerDisplay(seconds) {
                const m = Math.floor(seconds / 60).toString().padStart(2, '0');
                const s = (seconds % 60).toString().padStart(2, '0');
                focusTimer.textContent = `${m}:${s}`;
            }

            function stopTimer() {
                if (timerWorker) {
                    timerWorker.postMessage({ action: 'stop' });
                }
                if (timerInterval) clearInterval(timerInterval);
                timerInterval = null;
            }

            function nextSet() {
                const ex = currentWorkout.exercises[currentExerciseIndex];
                const isSuperset = !!ex.supersetId;
                
                if (currentSetIndex < ex.sets.length - 1) {
                    const previousSet = ex.sets[currentSetIndex];
                    currentSetIndex++;
                    const upcomingSet = ex.sets[currentSetIndex];
                    if (previousSet && upcomingSet) {
                        if ((!upcomingSet.weight || upcomingSet.weight === 0) && previousSet.weight) {
                            upcomingSet.weight = previousSet.weight;
                        }
                        if ((upcomingSet.reps === '' || upcomingSet.reps === undefined || upcomingSet.reps === null) && previousSet.reps) {
                            upcomingSet.reps = previousSet.reps;
                        }
                        if (!upcomingSet.target && previousSet.target) {
                            upcomingSet.target = previousSet.target;
                        }
                    }
                } else {
                    // Finished all sets of current exercise
                    
                    // IF Sequential Mode (Alternating) - only if NOT in combined mode
                    // If we are in combined mode, we finish A and B together, so we don't alternate sets individually.
                    if (isSuperset && ex.supersetRole === 'B' && !supersetModeActive) {
                        // After completing B, go back to A for next round
                        const prevEx = currentWorkout.exercises[currentExerciseIndex - 1];
                        if (prevEx?.supersetId === ex.supersetId && prevEx?.supersetRole === 'A') {
                            // Check if A has more sets to do
                            const completedRoundsA = prevEx.sets.filter(s => s.weight > 0).length;
                            
                            if (completedRoundsA < prevEx.sets.length) {
                                // Go back to A
                                currentExerciseIndex--;
                                currentSetIndex = completedRoundsA;
                                focusHistoryList.innerHTML = ''; // Clear for new round
                                updateFocusUI();
                                return;
                            }
                        }
                    }
                    
                    // Move to next exercise
                    currentSetIndex = 0;
                    currentExerciseIndex++;
                    focusHistoryList.innerHTML = ''; // Clear history for new exercise
                    
                    // CHECK FOR COMPLETED SUPERSET PARTNER (Combined Mode)
                    // If we just finished A (in combined mode), we are now at B.
                    // But B is already done. So we should skip it.
                    if (currentExerciseIndex < currentWorkout.exercises.length) {
                        const newEx = currentWorkout.exercises[currentExerciseIndex];
                        const prevEx = currentWorkout.exercises[currentExerciseIndex - 1];
                        
                        // If we just moved from A -> B, and B is the partner
                        if (prevEx && prevEx.supersetId && newEx.supersetId === prevEx.supersetId && newEx.supersetRole === 'B') {
                            // Check if B is already fully completed (e.g. via combined logging)
                            // We check if all sets have weight logged
                            const allSetsDone = newEx.sets.every(s => s.weight > 0);
                            
                            if (allSetsDone) {
                                console.log('[Focus] Skipping completed superset partner:', newEx.name);
                                currentExerciseIndex++;
                                focusHistoryList.innerHTML = '';
                            }
                        }
                    }
                }
                updateFocusUI();
            }

            function finishWorkout(empty = false) {
                sessionCompleted = true;
                
                // Mark session as completed for recovery manager
                window.focusModeSessionCompleted = true;
                
                // Stop silent audio loop and release wake lock
                notificationManager.stopSilentLoop();
                notificationManager.releaseWakeLock();
                
                focusActiveArea.style.display = 'none';
                focusTimerArea.style.display = 'none';
                focusActionBtn.textContent = "CHIUDI";
                focusActionBtn.className = 'btn btn-primary';
                focusActionBtn.style.background = 'var(--color-primary)';
                focusActionBtn.style.border = 'none';
                focusActionBtn.style.color = 'black';
                focusHistoryList.innerHTML = '';

                if (empty) {
                    focusExerciseName.textContent = "Nessun esercizio disponibile";
                    focusSetCounter.textContent = "Aggiorna la scheda per iniziare.";
                    focusProgressBar.style.width = '0%';
                    focusProgressText.textContent = '0%';
                    sessionLogSaved = true;
                } else {
                    focusExerciseName.textContent = "Workout Completato!";
                    focusSetCounter.textContent = "Ottimo lavoro.";
                    focusProgressBar.style.width = '100%';
                    focusProgressText.textContent = '100%';
                    persistFocusLog();
                }
            }

            async function persistFocusLog() {
                if (sessionLogSaved) return;
                if (!currentWorkout || !Array.isArray(currentWorkout.exercises)) return;

                const exercises = currentWorkout.exercises.map(ex => {
                    const validSets = (ex.sets || []).map(set => {
                        const weightVal = Number(set.weight) || 0;
                        const repsVal = parseFloat(set.reps ?? set.target);
                        if (weightVal <= 0 || !Number.isFinite(repsVal) || repsVal <= 0) return null;
                        
                        // Include RPE and set type if available
                        const setData = { weight: weightVal, reps: repsVal };
                        if (set.rpe !== undefined && set.rpe !== null && set.rpe !== '') {
                            setData.rpe = Number(set.rpe);
                        }
                        // Include set type if not normal
                        if (set.type && set.type !== 'normal') {
                            setData.type = set.type;
                        }
                        return setData;
                    }).filter(Boolean);

                    if (!validSets.length) return null;
                    
                    // Calculate average RPE for the exercise
                    const setsWithRpe = validSets.filter(s => s.rpe !== undefined);
                    const avgRpe = setsWithRpe.length > 0 
                        ? Math.round((setsWithRpe.reduce((sum, s) => sum + s.rpe, 0) / setsWithRpe.length) * 10) / 10
                        : undefined;
                    
                    const exerciseData = { name: ex.name, sets: validSets };
                    
                    // Include Superset Data
                    if (ex.supersetId) {
                        exerciseData.supersetId = ex.supersetId;
                        exerciseData.supersetRole = ex.supersetRole;
                        if (ex.intraRest !== undefined) exerciseData.intraRest = ex.intraRest;
                        if (ex.interRest !== undefined) exerciseData.interRest = ex.interRest;
                    }

                    if (avgRpe !== undefined) {
                        exerciseData.avgRpe = avgRpe;
                    }
                    return exerciseData;
                }).filter(Boolean);

                if (!exercises.length) {
                    sessionLogSaved = true;
                    return;
                }

                const totalVolume = exercises.reduce((acc, ex) => {
                    return acc + ex.sets.reduce((sum, set) => sum + (set.weight * set.reps), 0);
                }, 0);

                const durationMinutes = sessionStartTime
                    ? Math.max(1, Math.round((Date.now() - sessionStartTime) / 60000))
                    : null;

                // Calculate average RPE for the entire workout
                const exercisesWithRpe = exercises.filter(ex => ex.avgRpe !== undefined);
                const workoutAvgRpe = exercisesWithRpe.length > 0
                    ? Math.round((exercisesWithRpe.reduce((sum, ex) => sum + ex.avgRpe, 0) / exercisesWithRpe.length) * 10) / 10
                    : undefined;

                const logs = JSON.parse(localStorage.getItem('ironflow_logs') || '[]');
                const logEntry = {
                    id: Date.now(),
                    workoutId: currentWorkoutId,
                    workoutName: currentWorkout?.name || 'Workout',
                    date: new Date().toISOString(),
                    duration: durationMinutes ? `${durationMinutes} min` : '',
                    totalVolume,
                    exercises,
                    avgRpe: workoutAvgRpe, // Average RPE for the entire workout
                    wellness: currentWellnessSnapshot ? { ...currentWellnessSnapshot } : undefined,
                    fromAI: !!currentWorkout?.fromAI,
                    source: 'focus'
                };
                console.log('[Focus] Saving log with wellness:', logEntry.wellness);
                console.log('[Focus] sorenessMuscles in log:', logEntry.wellness?.sorenessMuscles);
                if (!logEntry.wellness) delete logEntry.wellness;
                if (logEntry.avgRpe === undefined) delete logEntry.avgRpe;
                logs.unshift(logEntry);
                localStorage.setItem('ironflow_logs', JSON.stringify(logs));
                sessionLogSaved = true;
                currentWellnessSnapshot = null;

                try {
                    await firestoreService.syncToCloud();
                } catch (error) {
                    console.warn('Sync diario da Focus fallita:', error.message || error);
                }
            }

            const aiKeyInput = document.getElementById('aiKeyInput');
            const saveAiKeyBtn = document.getElementById('saveAiKeyBtn');
            const aiKeyStatus = document.getElementById('aiKeyStatus');

            // Load existing key
            if (aiService.hasKey()) {
                aiKeyInput.value = aiService.apiKey;
            }

            saveAiKeyBtn.addEventListener('click', async () => {
                const key = aiKeyInput.value;
                if (key) {
                    aiService.saveKey(key);

                    // Persist to Firestore (Profile)
                    aiKeyStatus.textContent = 'Salvataggio...';
                    const result = await firestoreService.updateProfileField('geminiKey', key);

                    if (result.success) {
                        aiKeyStatus.textContent = 'Key salvata e sincronizzata!';
                        aiKeyStatus.style.color = 'var(--color-primary)';
                    } else {
                        aiKeyStatus.textContent = 'Salvata localmente. Errore Cloud.';
                    }
                    setTimeout(() => aiKeyStatus.textContent = '', 2000);
                }
            });

            // Export Data (Existing logic adapted)
            const exportBtn = document.getElementById('exportBtn');
            if (exportBtn) {
                exportBtn.addEventListener('click', () => {
                    const data = {
                        workouts: JSON.parse(localStorage.getItem('ironflow_workouts') || '[]'),
                        logs: JSON.parse(localStorage.getItem('ironflow_logs') || '[]'),
                        profile: JSON.parse(localStorage.getItem('ironflow_profile') || '{}'),
                        exportDate: new Date().toISOString()
                    };
                    const dataStr = "data:text/json;charset=utf-8," + encodeURIComponent(JSON.stringify(data, null, 2));
                    const downloadAnchorNode = document.createElement('a');
                    downloadAnchorNode.setAttribute("href", dataStr);
                    downloadAnchorNode.setAttribute("download", "gymbro_backup_" + new Date().toISOString().split('T')[0] + ".json");
                    document.body.appendChild(downloadAnchorNode);
                    downloadAnchorNode.click();
                    downloadAnchorNode.remove();
                });
            }


            window.addEventListener('storage', (event) => {
                if (event.key === 'ironflow_workouts') {
                    renderWorkouts();
                    syncFocusOverlayWithLatestPlan();
                }
            });

            window.addEventListener('focus', () => {
                renderWorkouts();
            });

            document.addEventListener('visibilitychange', () => {
                if (!document.hidden) renderWorkouts();
            });

            // --- Existing Workout List Logic (Preserved) ---
            function renderWorkouts() {
                const list = document.getElementById('savedWorkoutsList');
                const workouts = getStoredWorkouts();
                if (!list) return;

                list.innerHTML = '';

                if (workouts.length === 0) {
                    list.innerHTML = '<p style="color: var(--color-text-muted);">Nessuna scheda salvata.</p>';
                } else {
                    let normalized = false;
                    workouts.forEach((w) => {
                        if (!w.id) {
                            w.id = generateWorkoutId();
                            normalized = true;
                        }
                        if (!Array.isArray(w.exercises)) {
                            w.exercises = [];
                        }
                    });

                    if (normalized) {
                        localStorage.setItem('ironflow_workouts', JSON.stringify(workouts));
                    }

                    workouts.forEach((w, index) => {
                        const div = document.createElement('div');
                        div.className = 'workout-list-item';
                        const workoutIdAttr = w.id ? `data-id="${w.id}"` : '';
                        const workoutName = w.name || 'Workout senza nome';
                        const exercisesCount = Array.isArray(w.exercises) ? w.exercises.length : 0;
                        // Distingui AI classico da AI personalizzato
                        const isAI = w.fromAI || w.aiGenerated;
                        const isPersonalized = w.aiPersonalized;
                        let aiBadge = '';
                        if (isAI) {
                            if (isPersonalized) {
                                aiBadge = '<span class="ai-badge" style="background: linear-gradient(135deg, rgba(0,243,255,0.3), rgba(156,39,176,0.3)); border-color: #9c27b0;">AI+</span>';
                            } else {
                                aiBadge = '<span class="ai-badge">AI</span>';
                            }
                        }
                        div.innerHTML = `
                            <div style="flex: 1;">
                                <strong>${workoutName} ${aiBadge}</strong>
                                <div style="font-size: 0.8rem; color: var(--color-text-muted);">${exercisesCount} Esercizi</div>
                            </div>
                            <div style="display: flex; gap: 0.5rem; align-items: center;">
                                <button class="btn-icon start-workout" data-index="${index}" ${workoutIdAttr} title="Avvia Focus Mode" style="background: var(--color-primary); color: black; border: none; width: 36px; height: 36px; border-radius: 50%; display: flex; align-items: center; justify-content: center; cursor: pointer;">
                                    ‚ñ∂
                                </button>
                                <a href="creator.html?id=${w.id}" style="padding: 0.5rem; font-size: 0.9rem; color: var(--color-text); text-decoration: none; border: 1px solid var(--color-border); border-radius: 4px;">Modifica</a>
                                <span class="share-workout" data-index="${index}" title="Condividi Scheda" style="padding: 0.5rem; cursor: pointer; font-size: 1.2rem;">üîó</span>
                                <span class="delete-workout" data-index="${index}" style="padding: 0.5rem; cursor: pointer;">üóëÔ∏è</span>
                            </div>
                        `;
                        list.appendChild(div);
                    });

                    list.querySelectorAll('.start-workout').forEach(btn => {
                        btn.addEventListener('click', (e) => {
                            const idx = Number(e.currentTarget.dataset.index);
                            const workoutId = e.currentTarget.dataset.id;
                            const stored = getStoredWorkouts();
                            let targetWorkout = workoutId ? stored.find(w => String(w.id) === String(workoutId)) : stored[idx];

                            if (!targetWorkout) {
                                alert('Scheda non trovata. Aggiorna la pagina per sincronizzare le modifiche.');
                                renderWorkouts();
                                return;
                            }

                            if (typeof window.initFocusMode === 'function') {
                                window.initFocusMode(targetWorkout);
                            } else {
                                alert('Focus Mode non ancora caricato. Riprova tra un secondo.');
                            }
                        });
                    });

                    // Share Workout Listener
                    list.querySelectorAll('.share-workout').forEach(btn => {
                        btn.addEventListener('click', async (e) => {
                            const idx = Number(e.target.dataset.index);
                            const stored = getStoredWorkouts();
                            const workout = stored[idx];
                            if (!workout) return;

                            e.target.textContent = '‚è≥';
                            try {
                                // URL-based sharing (No Database required)
                                const json = JSON.stringify(workout);
                                const encoded = btoa(encodeURIComponent(json));

                                const url = new URL(window.location.href);
                                url.searchParams.set('shareData', encoded);
                                url.searchParams.delete('shareId');

                                const shareUrl = url.toString();

                                if (shareUrl.length > 8000) {
                                    alert('Scheda troppo grande per la condivisione via link.');
                                    return;
                                }

                                // Native Share API (Mobile)
                                if (navigator.share) {
                                    await navigator.share({
                                        title: `Allenamento: ${workout.name}`,
                                        text: `Prova questa scheda di allenamento su GymBro: ${workout.name}`,
                                        url: shareUrl
                                    });
                                } else {
                                    // Desktop Fallback (Custom Modal)
                                    showShareModal(workout.name, shareUrl);
                                }

                            } catch (err) {
                                console.error(err);
                                if (err.name !== 'AbortError') {
                                    alert('Errore condivisione.');
                                }
                            } finally {
                                e.target.textContent = 'üîó';
                            }
                        });
                    });

                    list.querySelectorAll('.delete-workout').forEach(btn => {
                        btn.addEventListener('click', async (e) => {
                            if (confirm('Sei sicuro?')) {
                                const idx = Number(e.target.dataset.index);
                                if (Number.isNaN(idx)) return;
                                const workouts = getStoredWorkouts();
                                workouts.splice(idx, 1);
                                localStorage.setItem('ironflow_workouts', JSON.stringify(workouts));
                                renderWorkouts();
                                syncFocusOverlayWithLatestPlan();
                                // Auto sync deletion
                                if (authService.getCurrentUser()) {
                                    await firestoreService.syncToCloud();
                                }
                            }
                        });
                    });
                }
            }

            // Initial render
            renderWorkouts();

            // Unit toggle (Existing)
            if (window.unitService) {
                const unitSelect = document.querySelectorAll('.setting-item select')[0];
                unitSelect.value = window.unitService.getSystem() === 'imperial' ? 'Imperiale (lbs/in)' : 'Metrico (kg/cm)';
                unitSelect.addEventListener('change', (e) => {
                    const val = e.target.value;
                    if (val.includes('Imperiale')) window.unitService.toggleSystem('imperial');
                    else window.unitService.toggleSystem('metric');
                });
            }
        });
    </script>

    <!-- Health Auto Export Service (for Apple Health) -->
    <script src="js/health-auto-export-service.js"></script>
    
    <!-- Health Connect Integration Script (Google Fit + Apple Health via Health Auto Export) -->
    <script type="module">
        import { healthConnectService } from './js/health-connect-service.js';
        import { terraHealthService } from './js/terra-health-service.js';
        import { firestoreService } from './js/firestore-service.js';

        // UI Elements
        const providerSelection = document.getElementById('healthProviderSelection');
        const connectedActions = document.getElementById('healthConnectedActions');
        const connectGoogleFitBtn = document.getElementById('connectGoogleFitBtn');
        const connectAppleHealthBtn = document.getElementById('connectAppleHealthBtn');
        const syncBtn = document.getElementById('syncHealthBtn');
        const disconnectBtn = document.getElementById('disconnectHealthBtn');
        const statusText = document.getElementById('healthStatusText');
        const lastSyncEl = document.getElementById('healthLastSync');
        const lastSyncTime = document.getElementById('lastSyncTime');

        // Current connected provider
        let currentProvider = null;

        // Update UI based on connection status
        async function updateHealthStatus() {
            try {
                // Check which provider is connected
                currentProvider = await firestoreService.getConnectedHealthProvider();
                console.log('Current health provider:', currentProvider);

                if (currentProvider) {
                    // Connected to a provider
                    const providerName = currentProvider === 'google_fit' ? 'ü§ñ Google Fit' : 
                                        currentProvider.includes('apple') ? 'üçé Apple Health' : 
                                        'üè• ' + currentProvider;
                    
                    statusText.textContent = `‚úÖ Connesso a ${providerName}`;
                    statusText.style.color = '#10b981';
                    
                    providerSelection.style.display = 'none';
                    connectedActions.style.display = 'block';

                    // Show last sync time
                    const lastSync = await firestoreService.getLastHealthSync();
                    if (lastSync && lastSync.syncTimestamp) {
                        lastSyncEl.style.display = 'block';
                        lastSyncTime.textContent = new Date(lastSync.syncTimestamp).toLocaleString('it-IT');
                    }
                } else {
                    // Not connected
                    statusText.textContent = 'Non connesso';
                    statusText.style.color = 'var(--color-text-muted)';
                    
                    providerSelection.style.display = 'block';
                    connectedActions.style.display = 'none';
                    lastSyncEl.style.display = 'none';
                }
            } catch (error) {
                console.error('Error updating health status:', error);
                statusText.textContent = '‚ùå Errore caricamento stato';
                statusText.style.color = '#ef4444';
            }
        }

        // Connect Google Fit (Android)
        connectGoogleFitBtn.addEventListener('click', async () => {
            // Check for conflict with Terra
            const terraData = await firestoreService.getTerraUserData();
            if (terraData && terraData.userId) {
                alert('‚ö†Ô∏è Sei gi√† connesso ad Apple Health.\n\nPer usare Google Fit, devi prima disconnetterti da Apple Health.');
                return;
            }

            try {
                connectGoogleFitBtn.disabled = true;
                connectGoogleFitBtn.innerHTML = '‚è≥ Connessione...';

                await healthConnectService.connect();

                alert('‚úÖ Connesso a Google Fit!\nI tuoi dati verranno sincronizzati automaticamente.');
                await updateHealthStatus();
            } catch (error) {
                console.error('Errore connessione Google Fit:', error);
                alert('‚ùå Errore: ' + error.message);
            } finally {
                connectGoogleFitBtn.disabled = false;
                connectGoogleFitBtn.innerHTML = '<span style="font-size: 1.2rem;">ü§ñ</span> Google Fit <small style="font-size: 0.65rem; opacity: 0.7;">(Android)</small>';
            }
        });

        // Connect Apple Health (iOS via Health Auto Export app)
        connectAppleHealthBtn.addEventListener('click', async () => {
            // Check for conflict with Google Fit
            const googleFitConnected = await terraHealthService.isGoogleFitConnected();
            if (googleFitConnected) {
                alert('‚ö†Ô∏è Sei gi√† connesso a Google Fit.\n\nPer usare Apple Health, devi prima disconnetterti da Google Fit.');
                return;
            }

            try {
                // Show Health Auto Export setup modal
                await healthAutoExportService.showSetupModal();
                
                // After modal closes, check if configured
                setTimeout(async () => {
                    await updateHealthStatus();
                }, 1000);
            } catch (error) {
                console.error('Errore configurazione Apple Health:', error);
                alert('‚ùå Errore: ' + error.message);
            }
        });

        // Sync data
        syncBtn.addEventListener('click', async () => {
            try {
                syncBtn.disabled = true;
                syncBtn.innerHTML = '‚è≥ Sincronizzazione...';

                let result;
                if (currentProvider === 'google_fit') {
                    result = await healthConnectService.syncAllData();
                } else if (currentProvider === 'apple_health_auto_export') {
                    // Health Auto Export syncs automatically via webhook
                    // Just verify connection and show latest data
                    const isConnected = await healthAutoExportService.verifyConnection();
                    result = { success: isConnected };
                } else if (currentProvider && currentProvider.includes('terra')) {
                    await terraHealthService.loadUserConnection();
                    result = await terraHealthService.syncAllData();
                } else {
                    throw new Error('Nessun provider connesso');
                }

                if (result && result.success) {
                    alert('‚úÖ Dati sincronizzati con successo!');
                    await updateHealthStatus();
                } else {
                    alert('‚ùå Errore: ' + (result?.error || 'Errore sconosciuto'));
                }
            } catch (error) {
                console.error('Errore sync:', error);
                alert('‚ùå Errore: ' + error.message);
            } finally {
                syncBtn.disabled = false;
                syncBtn.innerHTML = '<span>üîÑ</span> Sincronizza Ora';
            }
        });

        // Disconnect
        disconnectBtn.addEventListener('click', async () => {
            const providerName = currentProvider === 'google_fit' ? 'Google Fit' : 'Apple Health';
            if (!confirm(`Sei sicuro di voler disconnettere ${providerName}?`)) return;

            try {
                disconnectBtn.disabled = true;
                disconnectBtn.innerHTML = '‚è≥...';

                if (currentProvider === 'google_fit') {
                    await healthConnectService.disconnect();
                } else if (currentProvider === 'apple_health_auto_export') {
                    await healthAutoExportService.disconnect();
                } else if (currentProvider && currentProvider.includes('terra')) {
                    await terraHealthService.loadUserConnection();
                    await terraHealthService.disconnect();
                }

                alert('‚úÖ Disconnesso con successo');
                await updateHealthStatus();
            } catch (error) {
                console.error('Errore disconnect:', error);
                alert('‚ùå Errore: ' + error.message);
            } finally {
                disconnectBtn.disabled = false;
                disconnectBtn.innerHTML = '<span>‚ùå</span> Disconnetti';
            }
        });

        // Listen for Terra connection events
        window.addEventListener('terraConnected', async (e) => {
            console.log('Terra connected event:', e.detail);
            await updateHealthStatus();
        });

        // Check URL for Terra callback
        async function checkTerraCallback() {
            const urlParams = new URLSearchParams(window.location.search);
            const terraStatus = urlParams.get('terra');
            
            if (terraStatus === 'success') {
                // Clean URL
                window.history.replaceState({}, document.title, window.location.pathname);
                // Refresh status
                await updateHealthStatus();
            } else if (terraStatus === 'error') {
                window.history.replaceState({}, document.title, window.location.pathname);
                alert('‚ùå Errore durante la connessione ad Apple Health. Riprova.');
            }
        }

        // Initialize
        document.addEventListener('DOMContentLoaded', async () => {
            await checkTerraCallback();
            await updateHealthStatus();
        });

        // Also update on page focus (in case user completed auth in another tab)
        document.addEventListener('visibilitychange', () => {
            if (!document.hidden) {
                updateHealthStatus();
            }
        });

        // Legacy: Keep old function name for compatibility
        document.addEventListener('DOMContentLoaded', () => {
            // Aspetta un momento per assicurarsi che l'autenticazione sia completa
            setTimeout(() => updateHealthStatus(), 500);
        });

        // Aggiorna status anche se gi√† caricato
        if (document.readyState === 'complete' || document.readyState === 'interactive') {
            setTimeout(() => updateHealthStatus(), 500);
        }

        // Ascolta i cambiamenti di autenticazione per aggiornare lo stato
        import('./js/auth-service.js').then(({ authService }) => {
            authService.subscribe((user) => {
                if (user) {
                    // Utente autenticato, aggiorna lo stato dopo un breve delay
                    setTimeout(() => updateHealthStatus(), 1000);
                }
            });
        });
    </script>
</body>
    
    <!-- Focus Mode Enhancements Loader -->
    <script type="module" src="./js/enhancements-loader.js"></script>

</html>